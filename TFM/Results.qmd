# Results
## Phenotypic Characterization

[@tbl-description] describes the phenotypical features of FATe patients selected for this study. This cohort encomprisses 78 subjects (24% males; 76% females), aged between 22 to 61 with obesity as regards of BMI levels of 46.11 ± 6.13 kg/m². These patients had an overall presence of general variables/descriptors of metabolic syndrome features of particular interest those related to liver/hepatic status (steatosis, lobular inflammation and the prevalence of associated metabolic diseases). According to the hepatic steatosis scale, 35.9% of patients had less than 5% liver fat, indicating a normal or minimal steatosis state. A total of 32.1% exhibited mild steatosis (5–33%), while 25.6% showed moderate fat accumulation (33–66%). Only 6.4% of patients presented severe steatosis (\>66%), with no significant differences between men and women (*p*= 0.818).

Regarding lobular inflammation, most patients (66.7%) had no lobular inflammation, while 24.4% exhibited fewer than two foci per microscopic field, and 3.8% showed severe inflammation (\>4 foci). Hepatocyte ballooning analysis revealed that 74.4% of patients did not display significant damage, although 9.0% showed severe ballooning.

Among most prevalent comorbidities, 26.9% of patients were diagnosed with diabetes, and 34.6% presented hyperlipidemia, with the latter being significantly more prevalent in men (63.2%) compared to women (25.4%, *p*= 0.006). Additionally, 15.4% of patients were classified with metabolic dysfunction-associated steatohepatitis (MASH), although this proportion showed no statistically significant differences between genders (*p*= 0.249). Collectively, these data highlight the heterogeneity in the clinical characteristics of the cohort, emphasizing the complexity of the metabolic relationship between obesity and liver disease in this cohort.

## Quality Control (QC) and reads preprocessing
All QC results from the various steps in the *nf-core/smrnaseq* pipeline are summarized in the following figures and tables. The evaluation of samples, both before and after processing, was conducted using *fastp*, a rapid tool designed for preprocessing RNA sequencing data. This tool includes features for adapter trimming, quality filtering, and report generation, making it essential for assessing sample quality. Overall, [@tbl-metrics] presents a descriptive analysis that includes key metrics related to the sequencing data.

\clearpage

```{r my-table, echo=FALSE, results='asis', message=FALSE, warning=FALSE}
#| tbl-cap: "Clinical characteristics of the FATe cohort"
#| label: "tbl-description"

library(kableExtra)

data <- data.frame(
  Characteristic = c(
    "Age (years) median",
    "Body Mass Index (kg/m²) median",
    "MASLD Activity Score Category (%):",
    " - 0",
    "  - 1",
    "- 2",
    "- 3",
    "- 4",
    "- >= 5",
    "Hepatic Steatosis Scale (%):",
    "- < 5%",
    "- 5-33%",
    "- > 33-66%",
    "- > 66%",
    "Hepatocytic ballooning Category (%):",
    "- None",
    "- Few cells",
    "- Many cells",
    "Lobular Inflammation Category (%):",
    "- No foci",
    "- < 2 foci/200x",
    "- 2-4 foci/200x",
    "- > 4 foci/200x",
    "Diabetes:",
    "- Yes (%)",
    "- No (%)",
    "Hyperlipidemia:",
    "- Yes (%)",
    "- No (%)",
    "Metabolic dysfunction-associated:",
    "- MASH (%)",
    "- Non-MASH (%)"
  ),
  Overall = c(
    "47.03 [13.75]", 
    "46.11 [8.70]", 
    "", 
    "22 (28.2)", "16 (20.5)", "17 (21.8)", "9 (11.5)", "9 (11.5)", "5 (6.4)",
    "", 
    "28 (35.9)", "25 (32.1)", "20 (25.6)", "5 (6.4)",
    "", 
    "58 (74.4)", "13 (16.7)", "7 (9.0)",
    "", 
    "52 (66.7)", "19 (24.4)", "4 (5.1)", "3 (3.8)",
    "", 
    "21 (26.9)", "57 (73.1)",
    "", 
    "27 (34.6)", "51 (65.4)",
    "", 
    "12 (15.4)", "66 (84.6)"
  ),
  Female = c(
    "46.53 [13]", 
    "45.68 [8.76]", 
    "", 
    "16 (27.1)", "13 (22.0)", "14 (23.7)", "7 (11.9)", "7 (11.9)", "2 (3.4)",
    "", 
    "21 (35.6)", "20 (33.9)", "15 (25.4)", "3 (5.1)",
    "", 
    "45 (76.3)", "10 (16.9)", "4 (6.8)",
    "", 
    "41 (69.5)", "14 (23.7)", "2 (3.4)", "2 (3.4)",
    "", 
    "16 (27.1)", "43 (72.9)",
    "", 
    "15 (25.4)", "44 (74.6)",
    "", 
    "7 (11.9)", "52 (88.1)"
  ),
  Male = c(
    "48.58 [14]", 
    "47.42 [8.70]", 
    "", 
    "6 (31.6)", "3 (15.8)", "3 (15.8)", "2 (10.5)", "2 (10.5)", "3 (15.8)",
    "", 
    "7 (36.8)", "5 (26.3)", "5 (26.3)", "2 (10.5)",
    "", 
    "13 (68.4)", "3 (15.8)", "3 (15.8)",
    "", 
    "11 (57.9)", "5 (26.3)", "2 (10.5)", "1 (5.3)",
    "", 
    "5 (26.3)", "14 (73.7)",
    "", 
    "12 (63.2)", "7 (36.8)",
    "", 
    "5 (26.3)", "14 (73.7)"
  ),
  p_test = c(
    "0.408", 
    "0.284", 
    "0.510", 
    "", "", "", "", "", "",
    "0.818", 
    "", "", "", "",
    "0.489", 
    "", "", "",
    "0.596", 
    "", "", "", "",
    "1.000", 
    "", "", 
    "0.006", 
    "", "", 
    "0.249", 
    "", ""
  )
)

# Crear la tabla
knitr::kable(data, 
      col.names = c("Characteristic", "Overall (n=78)", "Female (n=59)", "Male (n=19)", "p"), 
      format = "latex", 
      booktabs = TRUE,
      longtable = TRUE) %>%
  kable_styling(
    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
    font_size = 10.5) %>%
  row_spec(0, bold = TRUE) # Encabezado en negrita

cat("
\\vspace{-1em}
\\begin{flushleft}
\\footnotesize{
\\textbf{Description:} Data are presented as number of cases (%) or median [interquartile range]. 
Differences between groups were tested with the Mann–Whitney U test and chi-square test. 
\\textit{BMI}: Body Mass Index (kg/m²), 
\\textit{MASH:} Metabolic dysfunction-associated steatohepatitis.
}
\\end{flushleft}
")

```

\clearpage

```{r}
library(readr)
library(dplyr)
library(knitr)
library(tidyr)
library(psych)
library(kableExtra)
library(ggplot2)
library(ggrepel)
library(patchwork)
library(scales)
library(gridExtra)
library(tidyverse)


file_path_data <- "data/general_stats_table.tsv"  # Cambia esto por la ruta real
general_stats_data <- read.delim(file_path_data, header = TRUE, sep = "\t")

general_stats_data <- read_delim(file_path_data, delim = "\t", col_names = TRUE, na = c(".", "NA"), guess_max = 10000)

filtrados <- general_stats_data[grep("^SC_\\d+$", general_stats_data$Sample), ]
# Eliminar columnas sin informacion
filtrados <- filtrados %>% select(-`IsomiR %`, -`M IsomiR reads`,-`Error rate`,-`Non-primary`,-`Reads mapped`,-`Total seqs`,-`% Mapped`,-Seqs...16,-Seqs...21,-`M Ref miRNA reads`,-`M Reads`,-`Dups`,-`GC`,-`Avg len`,-`Median len`)

# Calcular estadísticas descriptivas
summary_metrics <- filtrados %>%
  summarise(
    Mean_Percent_Duplication = mean(`% Duplication`),
    Median_Percent_Duplication = median(`% Duplication`),
    IQR_Percent_Duplication = IQR(`% Duplication`),
    
    Mean_Reads_After_Filtering = mean(`Reads After Filtering`),
    Median_Reads_After_Filtering = median(`Reads After Filtering`),
    IQR_Reads_After_Filtering = IQR(`Reads After Filtering`),
    
    Mean_Percent_PF = mean(`% PF`),
    Median_Percent_PF = median(`% PF`),
    IQR_Percent_PF = IQR(`% PF`),
    
    Mean_Percent_Adapter = mean(`% Adapter`),
    Median_Percent_Adapter = median(`% Adapter`),
    IQR_Percent_Adapter = IQR(`% Adapter`),
    
    Mean_GC_content = mean(`GC content`),
    Median_GC_content = median(`GC content`),
    IQR_GC_content = IQR(`GC content`)
  )

summary_stats <- describe(filtrados[ , -1])  # Excluir la columna 'Sample' si no es numérica
summary_stats <- summary_stats %>% select(-vars, -se, -trimmed, -mad,-n, -skew,-kurtosis)


rownames(summary_stats) <- c("% Duplication", "Reads After Filtering (M)", "% GC content","% PF", "% Adapter")

summary_stats[, 2:ncol(summary_stats)] <- round(summary_stats[, 2:ncol(summary_stats)], 2)
```
```{r table fast p, echo=FALSE, results='asis', message=FALSE, warning=FALSE}
#| tbl-cap: "Descriptive statistics of the analyzed metrics with fastp"
#| label: "tbl-metrics"
knitr::kable(summary_stats,
             col.names = c("", "Mean", 
                              "sd", "Median", 
                              "Minimum", "Maximum", "Range"),)%>%
  kable_styling(
    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
    font_size = 11   # Ajustar tamaño de fuente
  ) %>%
  row_spec(0, bold = TRUE) # Encabezado en negrita

cat("
\\vspace{-1em}
\\begin{flushleft}
\\footnotesize{
\\textbf{Description:}  
\\textit{\\% Duplication}: Duplication rate before filtering, 
\\textit{Reads After Filtering:} Total reads after filtering in million,
\\textit{\\%  GC content:} GC content after filtering,
\\textit{\\%  PF:} Percent reads passing filter,
\\textit{\\%  Adapter:} Percentage adapter-trimmed reads
}
\\end{flushleft}
")

```

The metrics obtained from the fastp analysis provide a detailed overview of the preprocessing performance across the samples. The percentage of duplicated reads before filtering was notably high, with a mean of 98.31% (±0.68), a median of 98.45%, and a range between 94.31% and 99.09%. After filtering, the number of reads retained per sample averaged 25.23 million (±5.67M) suggesting a reasonable amount of reads obtained, with a median of 25.82M and a range from 1.51M to 35.47M.

The GC content showed consistency across the samples, with an average of 46.72% (±1.68), a median of 46.43%, and a range between 43.26% and 50.89%. The percentage of pass-filtered (PF%) reads was high, with an average of 99.02% (±1.21), reaching a maximum of 99.76%, as shown in [@fig-filter_reads].

```{r fig-filter_reads,fig.width=8, fig.height=3, fig.pos="H"}
#| label: fig-filter_reads
#| fig-cap: "Fastp: Filtered Reads"

# Cargar datos
filter_fastp <- read.table("data/fastp_filtered_reads_plot.tsv", header = TRUE, sep = "\t")

# Transformación de los datos
data_fastp <- filter_fastp %>%
  pivot_longer(cols = -Sample, names_to = "Category", values_to = "Reads") %>%
  group_by(Sample) %>%
  mutate(Proportion = Reads / sum(Reads)) %>%  # Calcular proporciones por muestra
  ungroup()

# Gráfico de barras apiladas al 100%
ggplot(data_fastp, aes(x = Sample, y = Proportion, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "",
    x = "",
    y = "Reads (%)"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis", 
                       labels = c(
                         "Passed.Filter" = "Passed Filter",
                         "Low.Quality" = "Low Quality",
                         "Too.Many.N" = "Too Many N",
                         "Too.Short" = "Too Short"
                         ))+
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
  )
```

The adapters used in library construction, specifically the *Illumina Universal Adapter* type, are optimized for the amplification and sequencing of diverse sample types. The adapter trimming was highly effective, achieving a mean success rate of 99.38% (±0.35) with a range from 96.96% to 99.62%. ([@tbl-metrics]). In line with these findings, [@fig-adaptercontent]  illustrates the adapter content before and after processing with *fastp*, where the mean trimming percentage of 0.05 ± 0.06% for scWAT samples indicates that adapters were effectively removed from all samples. These results confirm the efficiency of the preprocessing steps, ensuring that high-quality reads were retained while effectively eliminating low-quality sequences and adapters.

```{r data adapter}
## FastQC Adapter Trimmed ##
# Cargar los datos desde un archivo .tsv
file_path_trimed <- "data/fastqc-1_adapter_content.tsv"  # Cambia esto por la ruta real
data_adapter_trimmed <- read.delim(file_path_trimed, header = TRUE, sep = "\t")

# Renombrar las columnas
colnames(data_adapter_trimmed) <- c("Sample", as.character(1:39))  # Asumiendo que tus columnas son del 1 al 39

# Transformar los datos de formato ancho a formato largo
data_long_adapter_trimmed <- pivot_longer(data_adapter_trimmed, cols = -Sample, names_to = "bp", values_to = "Contenido")

# Convertir el contenido a porcentajes
data_long_adapter_trimmed$Contenido <- data_long_adapter_trimmed$Contenido  # Convertir a porcentaje

# Filtrar solo las posiciones de 1 a 30
data_long_adapter_trimmed <-data_long_adapter_trimmed[data_long_adapter_trimmed$bp %in% as.character(1:39), ]

#mean(data_long_adapter_trimmed$Contenido)
#sd(data_long_adapter_trimmed$Contenido)

#summary(data_long_adapter_trimmed$Contenido)
################################################################################

### FastQC Adapter Raw ###

# Cargar los datos desde un archivo .tsv
file_path_raw <- "data/fastqc_adapter_content.tsv"  # Cambia esto por la ruta real
data_adapter_raw <- read.delim(file_path_raw, header = TRUE, sep = "\t")

# Renombrar las columnas
colnames(data_adapter_raw) <- c("Sample", as.character(1:39))  # Asumiendo que tus columnas son del 1 al 39

# Transformar los datos de formato ancho a formato largo
data_long_adapter_raw <- pivot_longer(data_adapter_raw, cols = -Sample, names_to = "bp", values_to = "Contenido")

# Convertir el contenido a porcentajes
data_long_adapter_raw$Contenido <- data_long_adapter_raw$Contenido  # Convertir a porcentaje

# Filtrar solo las posiciones de 1 a 30
data_long_adapter_raw <-data_long_adapter_raw[data_long_adapter_raw$bp %in% as.character(1:39), ]
```
```{r PLOT adapter, fig.width=8, fig.height=3, fig.pos='H'}
#| label: fig-adaptercontent
#| fig-cap: "Adapters Content (%) across all bases before (A) and after (B) using *fastp* (version 0.23.4)"

### FastQC: Adapter Content (raw)
p9 <- ggplot(data_long_adapter_raw, aes(x = as.numeric(bp), y = Contenido, color = Sample, group = Sample)) +
  geom_line() +
  labs(title = "A",
       subtitle = "Raw",
       x = "Position (bp)",
       y = "Percentage of Sequences") +
  theme_minimal() +
  scale_color_viridis_d(option = "viridis") + 

  scale_y_continuous(limits = c(0, 100), labels = scales::percent_format(scale = 1)) +  # Establecer límites del eje Y hasta 5%
    theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  ) # Eliminar leyenda # Eliminar leyenda  # Eliminar leyenda

### FastQC: Adapter Content (trimmed)
p10 <- ggplot(data_long_adapter_trimmed, aes(x = as.numeric(bp), y = Contenido, color = Sample, group = Sample)) +
  geom_line() +
  labs(title = "B",
       subtitle = "Trimmed",
       x = "Position (bp)",
       y = "") +
  theme_minimal() +
  scale_color_viridis_d(option = "") +  # Aplicar la paleta Cividis
  scale_y_continuous(limits = c(0, 2), labels = scales::percent_format(scale = 1)) +  # Establecer límites del eje Y hasta 5%
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 10),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 8),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  ) # Eliminar leyenda # Eliminar leyenda  # Eliminar leyenda

# Unir los gráficos en una fila
grid.arrange(p9, p10, ncol = 2)
```

[@fig-fstqc_quality_control] shows the analysis of the mean quality value of sequences across all bases, both before (*A*) and after (*B*) processing with *fastp*, it is evident from that the sequences from all samples consistently fall within an acceptable quality range, with mean Phred scores exceeding 30. This indicates a high base-calling accuracy, with an error probability of less than 0.1%, ensuring robust data integrity throughout the process. 

However, there is a noticeable drop in quality towards the extremes of the readings, particularly at position 31 bp. This decline can be attributed to the effects of adapter trimming in smRNA-seq. Even though adapters have been removed, if they were present at the end of the sequence, their trimming may result in reduced quality for the subsequent bases. Bases near the adapter might have lower quality, leading to a set of bases that, while technically valid, originate from a lower-quality region. Additionally, it is common in smRNA-seq to encounter contaminants from various sources, such as rRNA or tRNA, which introduce background noise and can further diminish the quality of the readings obtained.

The [@fig-fstqc_quality_control] illustrates the metric of the average quality value of each sequence across all samples. Before processing with *fastp* (*C*), the Phred scores consistently exceed 30, with most samples achieving scores around 35. This indicates that the average sequence quality is optimal, ensuring high reliability and low error rates. However, after trimming (*D*) a slight decrease in both Phred scores and read counts is observed. This reduction in the number of reads is expected after strict preprocessing with *fastp*, especially if contaminated or low-quality reads were present.

In [@fig-fstqc_quality_control] (*E*), prior to trimming, the GC content distribution does not follow a normal pattern. Multiple peaks are observed, probably due to the presence of adapters, which typically have a fixed GC content that generates specific peaks. Additionally, since this is a *small RNA-seq* experiment, contamination from rRNA or tRNA is common, as these molecules often have a different GC content compared to other small RNAs. After processing with *fastp* (*F*), the GC content decreases, indicating that most of these contaminant sequences have been removed, leaving of reads with anomalies. This remaining may correspond to sequences that are difficult to classify or contaminants that are not easily eliminated by *fastp*.

Additionally, no issues with the presence of ambiguous bases (Ns) are detected in any of the samples before and after trimming. [@fig-fstqc_quality_control] (*G* and *H*).

```{r data qualityhistograms}
### FastQC: Quality Histograms Raw
# Cargar los datos desde un archivo .tsv
file_path_sq <- "data/fastqc_per_base_sequence_quality_plot.tsv"  # Cambia esto por la ruta real
data_sq <- read.delim(file_path_sq, header = TRUE, sep = "\t")
# Renombrar las columnas
colnames(data_sq) <- c("Sample", as.character(1:(ncol(data_sq) - 1))) 
# Transformar los datos de formato ancho a formato largo
data_long_sq<- pivot_longer(data_sq, cols = -Sample, names_to = "bp", values_to = "Contenido")
# Convertir el contenido a porcentajes
data_long_sq$Contenido <- data_long_sq$Contenido  # Convertir a porcentaje
# Filtrar solo las posiciones de 1 a 30
data_long_sq <- data_long_sq[data_long_sq$bp %in% as.character(1:49), ]

################################################################################
### FastQC: Quality Histograms Trimmed
# Cargar los datos desde un archivo .tsv
file_path_sqt <- "data/fastqc-1_per_base_sequence_quality_plot.tsv"  # Cambia esto por la ruta real
data_sqt <- read.delim(file_path_sqt, header = TRUE, sep = "\t")
# Renombrar las columnas
colnames(data_sqt) <- c("Sample", as.character(1:(ncol(data_sqt) - 1))) 
# Transformar los datos de formato ancho a formato largo
data_long_sqt <- pivot_longer(data_sqt, cols = -Sample, names_to = "bp", values_to = "Contenido")
# Convertir el contenido a porcentajes
data_long_sq$Contenido <- data_long_sq$Contenido  # Convertir a porcentaje
# Filtrar solo las posiciones de 1 a 30
data_long_sqt <- data_long_sqt[data_long_sqt$bp %in% as.character(1:49), ]
```
```{r PLOT qualityhistograms, fig.width=8, fig.height=3,fig.pos='H'}
# Primer gráfico: FastQC: Quality Histograms Raw
p1 <- ggplot(data_long_sq, aes(x = as.numeric(bp), y = Contenido, color = Sample, group = Sample)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red", alpha = 0.8) +
  geom_hline(yintercept = 20, linetype = "dashed", color = "orange", alpha = 0.8) +
  geom_hline(yintercept = 28, linetype = "dashed", color = "green", alpha = 0.8) +
  geom_hline(yintercept = 38, linetype = "dashed", color = "green", alpha = 0.8) +
  geom_line() +
  labs(title = "A",
       subtitle = "Raw",
       x = "Position (bp)",
       y = "Phred Score") +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 38)) +
  scale_color_viridis_d(option = "Cividis") +  # Aplicar la paleta Cividis
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  )

# Segundo gráfico: FastQC: Quality Histograms (trimmed)
p2 <- ggplot(data_long_sqt, aes(x = as.numeric(bp), y = Contenido, color = Sample, group = Sample)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red", alpha = 0.8) +
  geom_hline(yintercept = 20, linetype = "dashed", color = "orange", alpha = 0.8) +
  geom_hline(yintercept = 28, linetype = "dashed", color = "green", alpha = 0.8) +
  geom_hline(yintercept = 38, linetype = "dashed", color = "green", alpha = 0.8) +
  geom_line() +
  labs(title = "B",
       subtitle = "Trimmed",
       x = "Position (bp)",
       y = "") +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 38)) +
  scale_color_viridis_d(option = "Cividis") +  # Aplicar la paleta Cividis
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  )
# Unir los gráficos en una fila
#grid.arrange(p1, p2, ncol = 2)

```
```{r data per_sequence_quality_score}
# Cargar los datos desde un archivo .tsv
file_path_psq <- "data/fastqc_per_sequence_quality_scores_plot.txt"  # Cambia esto por la ruta real
data_psq <- read.delim(file_path_psq, header = TRUE, sep = "\t")
  
file_path_psqs <- "data/fastqc-1_per_sequence_quality_scores_plot.txt"  # Cambia esto por la ruta real
data_psqs <- read.delim(file_path_psqs, header = TRUE, sep = "\t")
  
################################################################################

long_data_psq <- data_psq %>%
pivot_longer(cols = -Sample, names_to = "Index", values_to = "Pair") %>%
mutate(Pair = str_remove_all(Pair, "[()]")) %>% # Eliminar paréntesis
separate(Pair, into = c("X", "Y"), sep = ",", convert = TRUE) # Dividir en X e Y
  
long_data_psqs <- data_psqs %>%
pivot_longer(cols = -Sample, names_to = "Index", values_to = "Pair") %>%
mutate(Pair = str_remove_all(Pair, "[()]")) %>% # Eliminar paréntesis
separate(Pair, into = c("X", "Y"), sep = ",", convert = TRUE) # Dividir en X e Y
```
```{r PLOT per_sequence_quality_score, fig.width=8, fig.height=3,fig.pos='H'}
# Primer gráfico
p3 <- ggplot(long_data_psq, aes(x = as.numeric(X), y = as.numeric(Y), color = Sample)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", alpha = 0.8) +
  geom_vline(xintercept = 20, linetype = "dashed", color = "orange", alpha = 0.8) +
  geom_vline(xintercept = 27, linetype = "dashed", color = "green", alpha = 0.8) +
  geom_line() +
  labs(title = "C",
       subtitle = "Raw",
       x = "Mean Sequence Quality (Phred Score)",
       y = "Count") +
  scale_y_continuous(labels = label_number(scale = 1e-6, suffix = "M")) + # Escalar a millones
  theme_minimal() +
  scale_color_viridis_d(option = "Cividis") +  # Aplicar la paleta Cividis
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  )

# Segundo gráfico
p4 <- ggplot(long_data_psqs, aes(x = as.numeric(X), y = as.numeric(Y), color = Sample)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", alpha = 0.8) +
  geom_vline(xintercept = 20, linetype = "dashed", color = "orange", alpha = 0.8) +
  geom_vline(xintercept = 27, linetype = "dashed", color = "green", alpha = 0.8) +
  geom_line() +
  labs(title = "D",
       subtitle = "Trimmed",
       x = "Mean Sequence Quality (Phred Score)",
       y = "") +
  scale_y_continuous(labels = label_number(scale = 1e-6, suffix = "M")) + # Escalar a millones
  theme_minimal() + 
  scale_color_viridis_d(option = "Cividis") +  # Aplicar la paleta Cividis
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  )
# Unir los gráficos en una fila
#grid.arrange(p3, p4, ncol = 2)

```
```{r data GC}
### FastQC: Per Sequence GC Content Raw
# Cargar los datos desde un archivo .tsv
file_path_gc <- "data/fastqc_per_sequence_gc_content_plot.tsv"  # Cambia esto por la ruta real
data_gc <- read.delim(file_path_gc, header = TRUE, sep = "\t")

# Renombrar las columnas
colnames(data_gc) <- c("Sample", as.character(1:(ncol(data_gc) - 1))) 

# Transformar los datos de formato ancho a formato largo
data_long_gc <- pivot_longer(data_gc, cols = -Sample, names_to = "bp", values_to = "Contenido")

# Convertir el contenido a porcentajes
data_long_gc$Contenido <- data_long_gc$Contenido  # Convertir a porcentaje

# Filtrar solo las posiciones de 1 a 30
data_long_gc <- data_long_gc[data_long_gc$bp %in% as.character(1:101), ]

################################################################################

### FastQC: QPer Sequence GC Content Trimmed

# Cargar los datos desde un archivo .tsv
file_path_gct <- "data/fastqc-1_per_sequence_gc_content_plot.tsv"  # Cambia esto por la ruta real
data_gct <- read.delim(file_path_gct, header = TRUE, sep = "\t")

# Renombrar las columnas
colnames(data_gct) <- c("Sample", as.character(1:(ncol(data_gct) - 1))) 

# Transformar los datos de formato ancho a formato largo
data_long_gct <- pivot_longer(data_gct, cols = -Sample, names_to = "bp", values_to = "Contenido")

# Filtrar solo las posiciones de 1 a 30
data_long_gct <- data_long_gct[data_long_gct$bp %in% as.character(1:101), ]
```
```{r PLOT GC, fig.width=8, fig.height=3,fig.pos='H'}
# Primer gráfico: FastQC: Quality Histograms Raw
p5 <- ggplot(data_long_gc, aes(x = as.numeric(bp), y = Contenido, color = Sample, group = Sample)) +
  geom_line() +
  labs(title = "E",
       subtitle = "Raw",
       x = "% GC",
       y = "Percentage of counts") +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 40), labels = scales::percent_format(scale = 1)) +  # Mantén los límites sin formato de porcentaje
  scale_color_viridis_d(option = "Cividis") +  # Aplicar la paleta Cividis
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  )

# Segundo gráfico: FastQC: Quality Histograms (trimmed)
p6 <- ggplot(data_long_gct, aes(x = as.numeric(bp), y = Contenido, color = Sample, group = Sample)) +
  geom_line() +
  labs(title = "F",
       subtitle = "Trimmed",
       x = "% GC",
       y = "") +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 40), labels = scales::percent_format(scale = 1)) +  # Establecer límites del eje Y hasta 5%
  scale_color_viridis_d(option = "Cividis") +  # Aplicar la paleta Cividis
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  )

# Unir los gráficos en una fila
# grid.arrange(p5, p6, ncol = 2)

```
```{r data N}
### FastQC: Per Sequence GC Content Raw

# Cargar los datos desde un archivo .tsv
file_path_n <- "data/fastqc_per_base_n_content_plot.tsv"  # Cambia esto por la ruta real
data_n <- read.delim(file_path_n, header = TRUE, sep = "\t")

# Renombrar las columnas
colnames(data_n) <- c("Sample", as.character(1:(ncol(data_n) - 1))) 

# Transformar los datos de formato ancho a formato largo
data_long_n <- pivot_longer(data_n, cols = -Sample, names_to = "bp", values_to = "Contenido")

# Convertir el contenido a porcentajes
data_long_n$Contenido <- data_long_n$Contenido  # Convertir a porcentaje

# Filtrar solo las posiciones de 1 a 30
data_long_n <- data_long_n[data_long_n$bp %in% as.character(1:50), ]

################################################################################

### FastQC: QPer Sequence GC Content Trimmed

# Cargar los datos desde un archivo .tsv
file_path_nt <- "data/fastqc-1_per_base_n_content_plot.tsv"  # Cambia esto por la ruta real
data_nt <- read.delim(file_path_nt, header = TRUE, sep = "\t")

# Renombrar las columnas
colnames(data_nt) <- c("Sample", as.character(1:(ncol(data_nt) - 1))) 

# Transformar los datos de formato ancho a formato largo
data_long_nt <- pivot_longer(data_nt, cols = -Sample, names_to = "bp", values_to = "Contenido")

# Filtrar solo las posiciones de 1 a 30
data_long_nt <- data_long_nt[data_long_nt$bp %in% as.character(1:50), ]
```
```{r PLOT n, fig.width=8, fig.height=3,fig.pos='H'}
p7 <- ggplot(data_long_n, aes(x = as.numeric(bp), y = Contenido, color = Sample, group = Sample)) +
  geom_line() +
  labs(title = "G",
       subtitle = "Raw",
       x = "Position in read (bp)",
       y = "Percentage N-Count") +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 5), labels = scales::percent_format(scale = 1)) +  # Mantén los límites sin formato de porcentaje
  scale_color_viridis_d(option = "Cividis") +  # Aplicar la paleta Cividis
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  )
# Segundo gráfico: FastQC: Quality Histograms (trimmed)
p8 <- ggplot(data_long_nt, aes(x = as.numeric(bp), y = Contenido, color = Sample, group = Sample)) +
  geom_line() +
  labs(title = "H",
       subtitle = "Trimmed",
       x = "Position in read (bp)",
       y = "") +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 5), labels = scales::percent_format(scale = 1)) +  # Establecer límites del eje Y hasta 5%
  scale_color_viridis_d(option = "Cividis") +  # Aplicar la paleta Cividis
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  )
# Unir los gráficos en una fila
# grid.arrange(p7, p8, ncol = 2)

```
```{r fig-fstqc_quality_control, fig.width=8, fig.height=10,fig.pos='H'}
#| label: fig-fstqc_quality_control
#| fig-cap: "Quality Control Analysis. *A* and *B*: Mean quality values of sequences across all bases after ('Trimmed') and before ('Raw') using fastp (v0.23.4); *C* and *D*: Per Sequence Quality Scores across all bases after ('Trimmed') and before  ('Raw') using fastp; *E* and *F*: Per Sequence GC Content Raw after ('Trimmed') and before ('Raw') using fastp; *G* and *H*: Read N content after ('Trimmed') and before ('Raw') using fastp."

grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, 
             ncol = 2, 
             heights = rep(1, 4), # Espaciado uniforme entre filas
             widths = rep(1, 2)   # Espaciado uniforme entre columnas
)
```

However, the distribution of sequence lengths is irregular in the samples [@fig-sld]. After trimming, the majority of sequences cluster around a length of 20-25 nucleotides, although a smaller subset of sequences with lengths between 29-32 nucleotides is also observed. This indicates the presence of different types of small RNAs. Generally, miRNAs are found in the range of 20-24 bp, with a peak at 22 bp potentially indicating an abundant population of miRNAs. In contrast, tRNAs can vary in length but are commonly found at lengths that may include higher peaks, such as at 31 bp. This may reflect the presence of tRNAs derived from the degradation of double-stranded RNA or transposons.

```{r data Sequence Length Distribution}
# Cargar librerías
library(ggplot2)
library(tidyr)
library(dplyr)

################################################################################
### FastQC: Sequence Length Distribution
# Cargar los datos desde un archivo .tsv
file_path_sld <- "data/fastqc_sequence_length_distribution_plot.tsv"  # Cambia esto por la ruta real
data_sld <- read.delim(file_path_sld, header = TRUE, sep = "\t")

# Renombrar las columnas
colnames(data_sld) <- c("Sample", as.character(17:50)) 

# Transformar los datos de formato ancho a formato largo
data_long_sld <- pivot_longer(data_sld, cols = -Sample, names_to = "bp", values_to = "Contenido")

# Filtrar solo las posiciones de 1 a 30
data_long_sld <- data_long_sld[data_long_sld$bp %in% as.character(1:50), ]

```
```{r PLOT Sequence Length Distribution, fig.width=8, fig.height=2.5,fig.pos='H'}
#| label: fig-sld
#| fig-cap: "FastQC: Sequence Length Distribution"

library(scales)
### FastQC: Quality Histograms Raw
ggplot(data_long_sld, aes(x = as.numeric(bp), y = Contenido, color = Sample, group = Sample)) +
  geom_line() +
  labs(x = "Sequence Length (bp)",
       y = "Read Count") +
  theme_minimal() +
  scale_color_viridis_d(option = "Cividis") +  # Aplicar la paleta Cividis
  scale_y_continuous(labels = label_number(scale = 1e-6, suffix = "M")) + # Escalar a millones
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.subtitle = element_text(size = 10, hjust = 0.5 ),
    plot.title = element_text(size = 12, face = "bold"),
    plot.margin = margin(t = 10, r = 10, b = 30, l = 10),
    legend.position = "none"
  ) # Eliminar leyenda # Eliminar leyenda

#ggsave("Sequence Length.png", plot = sld, device = NULL, path = "figures/", scale = 1, width = 4, height = 3, units = "in", dpi = 300, limitsize = TRUE, bg = NULL, create.dir = FALSE)
```

In the [@fig-totalreads] shows the total number of reads *per* sample is around 25 million, both in Raw and Trimmed, with means of 25.47 and 25.23 million, respectively. The interquartile ranges (IQR) of these measurements are similar, approximately 4.2 million, reflecting a high consistency among the samples.

Regarding duplicate reads, they dominate the data, with means of 25.10 million in Raw and 24.95 million in Trimmed, and an IQR of about 4.2 million in both conditions. This indicates that more than 90% of the sequences are duplicated, a high value but expected in sRNA-seq samples, given the nature of the short reads of 20 to 24 nucleotides. 

In contrast, unique reads are significantly less frequent, with means of 0.38 million in Raw and 0.28 million in Trimmed. The interquartile ranges for these measurements are also low, around 0.13 million in Raw and 0.10 million in Trim.

```{r data totalreads }
# Cargar librerías
library(ggplot2)
library(tidyr)
library(dplyr)

################################################################################

### FastQC Total reads raw

# Cargar los datos desde un archivo .tsv
file_path_udr <- "data/fastqc_sequence_counts_plot.tsv"  # Cambia esto por la ruta real
data_udr <- read.delim(file_path_udr, header = TRUE, sep = "\t")

data_udr <- data_udr |>
  rename(
    Unique_reads = Unique.Reads,   # Cambiar Unique.Reads a Unique_Reads
    Duplicate_reads = Duplicate.Reads # Cambiar Duplicate.Reads a Duplicate_Reads
  ) |>
  mutate("Total reads" = Unique_reads + Duplicate_reads,
         "Condition" = "Raw")

# Transformar el dataframe
datos_longr <- pivot_longer(data_udr, cols = c("Unique_reads", "Duplicate_reads","Total reads"), 
                            names_to = "Type", values_to = "Reads")

################################################################################

### FastQC total reads after trimmming

# Cargar los datos desde un archivo .tsv
file_path_ud <- "data/fastqc-1_sequence_counts_plot.tsv"  # Cambia esto por la ruta real
data_ud <- read.delim(file_path_ud, header = TRUE, sep = "\t")

data_ud <- data_ud |>
  rename(
    Unique_reads = Unique.Reads,   # Cambiar Unique.Reads a Unique_Reads
    Duplicate_reads = Duplicate.Reads # Cambiar Duplicate.Reads a Duplicate_Reads
  )|>
  mutate("Total reads" = Unique_reads + Duplicate_reads,
         "Condition" = "Trimmed") 


# Transformar el dataframe
datos_long <- pivot_longer(data_ud, cols = c("Unique_reads", "Duplicate_reads","Total reads"), 
                           names_to = "Type", values_to = "Reads")

# Unir ambos dataframes
datos_combined <- bind_rows(datos_longr, datos_long)

# Convertir los valores de Reads a millones
datos_combined <- datos_combined |>
  mutate(Reads = Reads / 1e6)  # Dividir por 1,000,000 para convertir a millones
```
```{r PLOT totalreads, fig.width=6, fig.height=2.5,fig.pos='H'}
#| label: fig-totalreads
#| fig-cap: "Number of reads from small RNA-seq. Total reads before and after trimming of adapters"

ggplot(datos_combined, aes(x = Type, y = Reads, fill = Condition)) +  # Cambiar fill a Condition
  geom_boxplot(position = position_dodge(width = 0.75)) +
  theme_minimal() +
  labs(x = "",y = "Number of reads (millions)") +

  scale_fill_viridis_d(option = "cividis") +
  
  scale_x_discrete(labels = c("Duplicate_reads" = "Duplicate reads", 
                               "Total Reads" = "Total Reads", 
                               "Unique_reads" = "Unique reads")) +  # Cambiar los nombres aquí

  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 0 , hjust = 1, size = 9),
    axis.text.y = element_text(angle = 0 , hjust = 1, size = 9),
    axis.title = element_text(size = 10),
    plot.title = element_text(size = 12, face = "bold"),
    legend.position = "right",
    legend.title = element_blank()
  )   # Eliminar título de leyenda
```
```{r}
resumen_stats <- datos_combined |>
  group_by(Type, Condition) |>
  summarize(
    Media = mean(Reads),
    IQR = IQR(Reads),
    .groups = "drop"
  )
```

## miRNA Quality Control

The *nf-core/smrnaseq* pipeline performs a quality analysis specific to sRNA-seq data using *miRTrace*. This analysis assesses sequencing quality, identifies the presence of miRNA, and filters out unwanted sequences such as tRNA, rRNA, or Illumina artifacts. Additionally, it detects clade-specific miRNA profiles based on a comprehensive catalog of previously identified miRNA families.

In the annotation step [@fig-mirtrace_RNA_Categories], the mapped reads against reference databases revealed that a mean of 65.06% of analyzed sequences per sample corresponded to miRNA precursors, with a range of 22.51% to 91.77%. Other categories included 21.16% tRNA sequences, 9.16% unknown sequences, 4.55% rRNA sequences, and 0.05% artifacts.

```{r RNA Categories, fig.width=8, fig.height=3, fig.pos="H"}
#| label: fig-mirtrace_RNA_Categories
#| fig-cap: "*miRTrace* (v1.0.1) Analysis: RNA Categories"
##| 
# Gráfico 2: Tipos de RNA
tipos_rna <- read.table("data/mirtrace_rna_categories.txt", header = TRUE, sep = "\t")
tipos_rna_long <- tipos_rna %>%
  pivot_longer(cols = c(miRNA, rRNA, tRNA, Artifact, Unknown), 
               names_to = "Tipo_RNA", 
               values_to = "Conteo") %>%
  group_by(Sample) %>%
  mutate(Proporcion = Conteo / sum(Conteo)) %>% 
  ungroup()

#Plot
m2 <- ggplot(tipos_rna_long, aes(x = Sample, y = Proporcion, fill = Tipo_RNA)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "",
    x = "",
    y = "Quality filtered reads (%)"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis") +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90 , hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0 , hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)
  )

print(m2)
```

During the contamination assessment step [@fig-mirtrace_Contamination_Check], mapping miRNA precursor sequences against the clade-specific miRNA catalog showed that a mean of 94.14% of analyzed sequences belonged to the human category, with a range of 67.21% to 99.94%. Minor contributions from other clades, such as Rodentia (2.07%), Dicots (2.73%), Insects (0.58%), and Monocots (0.38%), were detected at low proportions. These identifications could result from contamination, such as incorrect index assignment during sample demultiplexing.

```{r Contamination Check, fig.width=8, fig.height=3, fig.pos="H"}
#| label: fig-mirtrace_Contamination_Check
#| fig-cap: "*miRTrace* (v1.0.1) Analysis: Contamination Check"
 
# Gráfico 3: Contaminación
mirtrace_data <- read.table("data/mirtrace_contamination_check_plot.tsv", header = TRUE, sep = "\t")

# Transformación de los datos
data_long <- mirtrace_data %>%
  pivot_longer(cols = c("gymnosperms", "monocots", "dicots", "nematode", 
                        "insects", "lophotrochozoa", "fish", "rodents", 
                        "primates", "bryophytes", "birds_reptiles"), 
               names_to = "Group", 
               values_to = "Conteo") %>%
  group_by(Sample) %>%
  mutate(Proporcion = Conteo / sum(Conteo)) %>% 
  ungroup()

# Gráfico de barras apiladas al 100%
m3 <- ggplot(data_long, aes(x = Sample, y = Proporcion, fill = Group)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "",
    x = "",
    y = "Clade-specific miRNAs (%)"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis", 
                       labels = c(
      "gymnosperms" = "Gymnosperms",
      "monocots" = "Monocots",
      "dicots" = "Dicots",
      "nematode" = "Nematode",
      "insects" = "Insects",
      "lophotrochozoa" = "Lophotrochozoa",
      "fish" = "Fish",
      "rodents" = "Rodents",
      "primates" = "Primates",
      "bryophytes" = "Bryophytes",
      "birds_reptiles" = "Birds & Reptiles"
    )) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
    legend.spacing.x = unit(0.3, "cm"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)
  ) +
  guides(fill = guide_legend(nrow = 2))  # Forzar que la leyenda tenga 2 filas

print(m3)

```

```{r QC,fig.width=8, fig.height=2.5, fig.pos="H"}
# Cargar datos
qc_mirna <- read.table("data/mirtrace_qc_plot.tsv", header = TRUE, sep = "\t")

# Transformación de los datos
data_long <- qc_mirna %>%
  pivot_longer(cols = -Sample, names_to = "Category", values_to = "Reads") %>%
  group_by(Sample) %>%
  mutate(Proportion = Reads / sum(Reads)) %>%  # Calcular proporciones por muestra
  ungroup()

# Gráfico de barras apiladas al 100%
m1 <- ggplot(data_long, aes(x = Sample, y = Proportion, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "A",
    x = "",
    y = "Reads (%)"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis", 
                       labels = c(
                         "Reads...18.nt.after.adapter.removal" = "Adapter detected, insert >= 18 nt",
                         "Reads.without.adapter" = "Adapter not detected",
                         "Reads...18.nt.after.adapter.removal.1" = "Length < 18 nt",
                         "Reads.with.low.complexity" = "Low complexity",
                         "Reads.with.low.PHRED.score" = "Low PHRED score"
                       ))+
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
  )
```
```{r RNA Categories, fig.width=8, fig.height=3}
# Gráfico 2: Tipos de RNA
tipos_rna <- read.table("data/mirtrace_rna_categories.txt", header = TRUE, sep = "\t")
tipos_rna_long <- tipos_rna %>%
  pivot_longer(cols = c(miRNA, rRNA, tRNA, Artifact, Unknown), 
               names_to = "Tipo_RNA", 
               values_to = "Conteo") %>%
  group_by(Sample) %>%
  mutate(Proporcion = Conteo / sum(Conteo)) %>% 
  ungroup()

#Plot
m2 <- ggplot(tipos_rna_long, aes(x = Sample, y = Proporcion, fill = Tipo_RNA)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "A",
    x = "",
    y = "Quality filtered reads (%)"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis") +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90 , hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0 , hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)
  )
```
```{r Contamination Check, fig.width=8, fig.height=3.5}
# Gráfico 3: Contaminación
mirtrace_data <- read.table("data/mirtrace_contamination_check_plot.tsv", header = TRUE, sep = "\t")

# Transformación de los datos
data_long <- mirtrace_data %>%
  pivot_longer(cols = c("gymnosperms", "monocots", "dicots", "nematode", 
                        "insects", "lophotrochozoa", "fish", "rodents", 
                        "primates", "bryophytes", "birds_reptiles"), 
               names_to = "Group", 
               values_to = "Conteo") %>%
  group_by(Sample) %>%
  mutate(Proporcion = Conteo / sum(Conteo)) %>% 
  ungroup()

# Gráfico de barras apiladas al 100%
m3 <- ggplot(data_long, aes(x = Sample, y = Proporcion, fill = Group)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "B",
    x = "",
    y = "Clade-specific miRNAs (%)"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis", 
                       labels = c(
      "gymnosperms" = "Gymnosperms",
      "monocots" = "Monocots",
      "dicots" = "Dicots",
      "nematode" = "Nematode",
      "insects" = "Insects",
      "lophotrochozoa" = "Lophotrochozoa",
      "fish" = "Fish",
      "rodents" = "Rodents",
      "primates" = "Primates",
      "bryophytes" = "Bryophytes",
      "birds_reptiles" = "Birds & Reptiles"
    )) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
    legend.spacing.x = unit(0.3, "cm"),
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)
  ) +
  guides(fill = guide_legend(nrow = 2))  # Forzar que la leyenda tenga 2 filas

```
```{r  fig-mirtrace_overall,fig.width=8, fig.height=6, fig.pos="H"}
##| label: fig-mirtrace
##| fig-cap: "*miRTrace* (v1.0.1) Analysis. *A*: RNA Categories; *B*: Contamination Check"

#grid.arrange(m2, m3,nrow = 2,  heights = rep(1, 2))
```

```{r Table of RNA Categories}
##| tbl-cap: "Descriptive statistics of Isomir Read counts "
##| label: "tbl-isomir_read_counts"

tipos_rna <- read.table("data/mirtrace_rna_categories.txt", header = TRUE, sep = "\t")

tipos_rna <- tipos_rna %>%
  mutate(Total = (miRNA+ tRNA + rRNA +  + Artifact + Unknown),
         miRNA_percentage = (miRNA/Total)* 100,
         tRNA_percentage = (tRNA/Total)* 100,
         rRNA_percentgae = (rRNA/Total)* 100,
         Artifact_percentage = (Artifact/Total)* 100,
         Unknown_percentage = (Unknown/Total)* 100)

stats_tipos_rna <- tipos_rna %>%
  summarise(
    Mean_miRNA_percentage = mean(miRNA_percentage, na.rm = TRUE),
    Max_miRNA_percentage = max(miRNA_percentage, na.rm = TRUE),
    Min_miRNA_percentage = min(miRNA_percentage, na.rm = TRUE),
    Mean_tRNA_percentage = mean(tRNA_percentage, na.rm = TRUE),
    Max_tRNA_percentage = max(tRNA_percentage, na.rm = TRUE),
    Min_tRNA_percentage = min(tRNA_percentage, na.rm = TRUE),
    Mean_rRNA_percentgae = mean(rRNA_percentgae, na.rm = TRUE),
    Max_rRNA_percentgae = max(rRNA_percentgae, na.rm = TRUE),
    Min_rRNA_percentgae = min(rRNA_percentgae, na.rm = TRUE), 
    Mean_Artifact_percentage = mean(Artifact_percentage, na.rm = TRUE),
    Max_Artifact_percentage = max(Artifact_percentage, na.rm = TRUE),
    Min_Artifact_percentage = min(Artifact_percentage, na.rm = TRUE),
    Mean_Unknown_percentage = mean(Unknown_percentage, na.rm = TRUE),
    Max_Unknown_percentage = max(Unknown_percentage, na.rm = TRUE),
    Min_Unknown_percentage = min(Unknown_percentage, na.rm = TRUE)
    ) 

#knitr::kable(stats_by_group,
#             col.names = c("Group", 
#                           "TM", 
#                           "TU", 
#                           "Mean M", 
#                           "Max M", 
#                           "Min M")) %>%
#  kable_styling(
#    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
#    font_size = 10.5   # Ajustar tamaño de fuente
#  ) %>%
#  row_spec(0, bold = TRUE) # Encabezado en negrita
```
```{r Table of  Contamination Check}
##| tbl-cap: "Descriptive statistics of Isomir Read counts "
##| label: "tbl-isomir_read_counts"
mirtrace_data <- read.table("data/mirtrace_contamination_check_plot.tsv", header = TRUE, sep = "\t")

mirtrace_data <- mirtrace_data %>%
  mutate(Total = (gymnosperms+ monocots + dicots + nematode + insects + lophotrochozoa + fish + rodents + primates + bryophytes + birds_reptiles),
         gymnosperms_percentage = (gymnosperms/Total)* 100,
         monocots_percentage = (monocots/Total)* 100,
         dicots_percentgae = (dicots/Total)* 100,
         nematode_percentage = (nematode/Total)* 100,
         insects_percentage = (insects/Total)* 100,
         lophotrochozoa_percentage = (lophotrochozoa/Total)* 100,
         fish_percentage = (fish/Total)* 100,
         rodents_percentage = (rodents/Total)* 100,
         primates_percentage = (primates/Total)* 100,
         bryophytes_percentage = (bryophytes/Total)* 100,
         birds_reptiles_percentage = (birds_reptiles/Total)* 100
         )

stats_mirtrace_data <- mirtrace_data %>%
  summarise(
    Mean_primates_percentage = mean( primates_percentage, na.rm = TRUE),
    Max_primates_percentage = max( primates_percentage, na.rm = TRUE),
    Min_primates_percentage = min( primates_percentage, na.rm = TRUE),
    Mean_birds_reptiles_percentage = mean(birds_reptiles_percentage, na.rm = TRUE),
    Mean_gymnosperms_percentgae = mean(gymnosperms_percentage, na.rm = TRUE),
    Mean_monocots_percentgae = mean(monocots_percentage, na.rm = TRUE),
    Mean_dicots_percentgae = mean(dicots_percentgae, na.rm = TRUE),
    Mean_nematode_percentgae = mean(nematode_percentage, na.rm = TRUE),
    Mean_insects_percentgae = mean(insects_percentage, na.rm = TRUE),
    Mean_lophotrochozoa_percentgae = mean(lophotrochozoa_percentage, na.rm = TRUE),
    Mean_fish_percentgae = mean(fish_percentage, na.rm = TRUE),
    Mean_rodents_percentgae = mean(rodents_percentage, na.rm = TRUE),
    Mean_bryophytes_percentgae = mean(bryophytes_percentage, na.rm = TRUE),
    ) 

#knitr::kable(stats_by_group,
#             col.names = c("Group", 
#                           "TM", 
#                           "TU", 
#                           "Mean M", 
#                           "Max M", 
#                           "Min M")) %>%
#  kable_styling(
#    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
#    font_size = 10.5   # Ajustar tamaño de fuente
#  ) %>%
#  row_spec(0, bold = TRUE) # Encabezado en negrita
```

## miRNA Quantification
In this step of the *nf-core/smrnaseq pipeline*, the alignment of reads is conducted sequentially against databases of mature miRNAs, precursor miRNAs, and a combined database of both. These alignments enable the identification and quantification of miRNAs. The statistics obtained for mature miRNAs, precursor miRNAs, and the combination of both against the reference genome are presented in [@tbl-samtools_overall]. On average, 52.07% of the mature miRNAs were mapped, with a range between 17.72% and 79.75%.

For precursor miRNAs, an average of 32.33% of sequences were identified, ranging from 6.31% to 68.83%. Subsequently, the reads of mature and precursor miRNAs were aligned against a reference genome, not for miRNA identification and quantification but as a quality control for the sequences. In this regard, the mean percentage of aligned reads was around 43% of the total reads. Across the sample set, minimum values of 10.28% and maximum values of 73.31% were observed. For more details, the metrics for each sample can be found in <https://github.com/joshoandres13/miRNAs>.

```{r}
#| tbl-cap: "Descriptive statistics of alignment with samtools of all samples. *TM*: Mean of Total Mapped (reads); *TU*: Mean of Total Unmapped (reads): *Mean M*: Mean Mapped (%); *Max M*: Max Mapped (%); *Min M*: Min Mapped (%) "
#| label: "tbl-samtools_overall"

file_path_sam <- "data/samtools_alignment_plot.tsv"  # Cambia esto por la ruta real
data_Stats_samtools <- read.table(file_path_sam, header = TRUE, sep = "\t")

data_Stats_samtools <- data_Stats_samtools %>%
  mutate(Percentage_Mapped = (Mapped..with.MQ.0. / (Mapped..with.MQ.0. + Unmapped)) * 100,
         Percentage_Unmapped = (Unmapped / (Mapped..with.MQ.0. + Unmapped)) * 100)

data_Stats_samtools$Group <- sub(".*_(mature_hairpin_genome|mature_hairpin|mature)$", "\\1", data_Stats_samtools$Sample)


# Agrupar por el grupo y calcular las estadísticas
library(dplyr)

stats_by_group <- data_Stats_samtools %>%
  group_by(Group) %>%
  summarise(
    Total_Mapped = mean(Mapped..with.MQ.0., na.rm = TRUE),
    Total_Unmapped = mean(Unmapped, na.rm = TRUE),
    Avg_Percentage_Mapped = mean(Percentage_Mapped, na.rm = TRUE),
    Avg_Percentage_Unmapped = mean(Percentage_Unmapped, na.rm = TRUE),
    Max_Percentage_Mapped = max(Percentage_Mapped, na.rm = TRUE),
    Min_Percentage_Mapped = min(Percentage_Mapped, na.rm = TRUE)
  ) %>%
  select(- Avg_Percentage_Unmapped)%>%
  mutate(
    Total_Mapped = round(Total_Mapped, 2),
    Total_Unmapped = round(Total_Unmapped, 2),
    Avg_Percentage_Mapped = round(Avg_Percentage_Mapped, 2),
    Max_Percentage_Mapped = round(Max_Percentage_Mapped, 2),
    Min_Percentage_Mapped = round(Min_Percentage_Mapped, 2)
  )

knitr::kable(stats_by_group,
             col.names = c("Group", 
                           "TM", 
                           "TU", 
                           "Mean M", 
                           "Max M", 
                           "Min M")) %>%
  kable_styling(
    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
    font_size = 11   # Ajustar tamaño de fuente
  ) %>%
  row_spec(0, bold = TRUE) # Encabezado en negrita
```

## IsomiR Annotation
*Mirtop* (v0.4.28) was used for the annotation of miRNAs and isomiRs. In [@fig-mirtop_mean_isomir_read_counts], the *mean isomiR read counts* are presented, which refer to an average calculation that helps to describe how the reads of isomiRs are distributed within a dataset. Among the annotated isomiR sequences per sample, the *reference miRNA* accounts for 96.51%, with ranges varying from 88.70% to 98.13%. On the other hand, the distributions of isomiR variants are as follows: *3' Isoform* (1.36%), *3' Addition* (1.23%), *5' Isoform* (0.64%), *SNVs in the Central Offset Region* (0.05%), *SNVs in the Central Region* (0.06%), *Supported SNVs in the Central Region* (0.05%), and *SNV in Seed Region* (0.05%), all of which are below 1.40%.

```{r fig-mirtop_mean_isomir_read_counts,fig.width=8, fig.height=2.75, fig.pos="H"}
#| label: fig-mirtop_mean_isomir_read_counts
#| fig-cap: "Annotation of miRNAs and isomiRs with *mirtop* (v0.4.28): Mean isomiR read counts"

# Mean isomiR read counts
mirtop_mean_isomir_read_counts_data <- read.table("data/mirtop_mean_read_count_plot.tsv", header = TRUE, sep = "\t")
mirtop_mean_isomir_read_counts_data <- mirtop_mean_isomir_read_counts_data %>%
  pivot_longer(cols = c(ref_miRNA,iso_3p,iso_5p,iso_add3p,iso_snv_seed,iso_snv_central_offset,iso_snv_central,iso_snv_central_supp), 
               names_to = "Isomirs", 
               values_to = "Conteo") %>%
  group_by(Sample) %>%
  mutate(Proporcion = Conteo / sum(Conteo)) %>% 
  ungroup()

#Plot
mirtop3 <- ggplot(mirtop_mean_isomir_read_counts_data, aes(x = Sample, y = Proporcion, fill = Isomirs)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "",
    x = "",
    y = "Means"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis", 
                       labels = c(
      "ref_miRNA" = "Reference miRNA",
      "iso_3p" = "3' Isoform",
      "iso_5p" = "5' Isoform",
      "iso_add3p" = "3' Addition",
      "iso_snv_seed" = "SNV in Seed Region",
      "iso_snv_central_offset" = "SNV in Central Offset Region",
      "iso_snv_central" = "SNV in Central Region",
      "iso_snv_central_supp" = "Supported SNV in Central Region"
    )) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90 , hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0 , hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)
  )

print(mirtop3)
```

```{r IsomiR read counts}
# IsomiR read counts
mirtop_read_count_data <- read.table("data/mirtop_read_count_plot.tsv", header = TRUE, sep = "\t")
mirtop_read_count_data <- mirtop_read_count_data %>%
  pivot_longer(cols = c(ref_miRNA,iso_3p,iso_5p,iso_add3p,iso_snv_seed,iso_snv_central_offset,iso_snv_central,iso_snv_central_supp), 
               names_to = "Isomirs", 
               values_to = "Conteo") %>%
  group_by(Sample) %>%
  mutate(Proporcion = Conteo / sum(Conteo)) %>% 
  ungroup()

#Plot
mirtop1 <- ggplot(mirtop_read_count_data, aes(x = Sample, y = Proporcion, fill = Isomirs)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "A",
    x = "",
    y = "Read counts"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis", 
                       labels = c(
      "ref_miRNA" = "Reference miRNA",
      "iso_3p" = "3' Isoform",
      "iso_5p" = "5' Isoform",
      "iso_add3p" = "3' Addition",
      "iso_snv_seed" = "SNV in Seed Region",
      "iso_snv_central_offset" = "SNV in Central Offset Region",
      "iso_snv_central" = "SNV in Central Region",
      "iso_snv_central_supp" = "Supported SNV in Central Region"
    )) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90 , hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0 , hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)
  )
```
```{r IsomiR unique read counts}
# IsomiR unique read counts
mirtop_unique_read_count_data <- read.table("data/mirtop_unique_read_count_plot.tsv", header = TRUE, sep = "\t")
mirtop_unique_read_count_data <- mirtop_unique_read_count_data %>%
  pivot_longer(cols = c(ref_miRNA,iso_3p,iso_5p,iso_add3p,iso_snv_seed,iso_snv_central_offset,iso_snv_central,iso_snv_central_supp), 
               names_to = "Isomirs", 
               values_to = "Conteo") %>%
  group_by(Sample) %>%
  mutate(Proporcion = Conteo / sum(Conteo)) %>% 
  ungroup()

#Plot
mirtop2 <- ggplot(mirtop_unique_read_count_data, aes(x = Sample, y = Proporcion, fill = Isomirs)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "B",
    x = "",
    y = "Unique sequences"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis", 
                       labels = c(
      "ref_miRNA" = "Reference miRNA",
      "iso_3p" = "3' Isoform",
      "iso_5p" = "5' Isoform",
      "iso_add3p" = "3' Addition",
      "iso_snv_seed" = "SNV in Seed Region",
      "iso_snv_central_offset" = "SNV in Central Offset Region",
      "iso_snv_central" = "SNV in Central Region",
      "iso_snv_central_supp" = "Supported SNV in Central Region"
    )) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90 , hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0 , hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)
  )
```
```{r Mean Isomir read counts}
# Mean isomiR read counts
mirtop_mean_isomir_read_counts_data <- read.table("data/mirtop_mean_read_count_plot.tsv", header = TRUE, sep = "\t")
mirtop_mean_isomir_read_counts_data <- mirtop_mean_isomir_read_counts_data %>%
  pivot_longer(cols = c(ref_miRNA,iso_3p,iso_5p,iso_add3p,iso_snv_seed,iso_snv_central_offset,iso_snv_central,iso_snv_central_supp), 
               names_to = "Isomirs", 
               values_to = "Conteo") %>%
  group_by(Sample) %>%
  mutate(Proporcion = Conteo / sum(Conteo)) %>% 
  ungroup()

#Plot
mirtop3 <- ggplot(mirtop_mean_isomir_read_counts_data, aes(x = Sample, y = Proporcion, fill = Isomirs)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9) +
  labs(
    title = "C",
    x = "",
    y = "Means"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(option = "cividis", 
                       labels = c(
      "ref_miRNA" = "Reference miRNA",
      "iso_3p" = "3' Isoform",
      "iso_5p" = "5' Isoform",
      "iso_add3p" = "3' Addition",
      "iso_snv_seed" = "SNV in Seed Region",
      "iso_snv_central_offset" = "SNV in Central Offset Region",
      "iso_snv_central" = "SNV in Central Region",
      "iso_snv_central_supp" = "Supported SNV in Central Region"
    )) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 90 , hjust = 1, size = 5),
    axis.text.y = element_text(angle = 0 , hjust = 1, size = 7),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    legend.margin = margin(t = -20),  # Ajusta el margen superior de la leyenda
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)
  )
```
```{r  fig-mirtop_overall,fig.width=8, fig.height=10, fig.pos="H"}
##| label: fig-mirtop
##| fig-cap: "Annotation of miRNAs and isomiRs with mirtop (v0.4.28). *A*: IsomiR read counts; *B*: IsomiR unique read counts; *C*: Mean isomiR read counts"

#grid.arrange(mirtop1, mirtop2, mirtop3, 
#             nrow = 3, 
#             heights = rep(1, 3) # Espaciado uniforme entre filas
#)
```

```{r Table of IsomiR read counts }
##| tbl-cap: "Descriptive statistics of Isomir Read counts "
##| label: "tbl-isomir_read_counts"
file <- "data/mirtop_read_count_plot.tsv"  
data_mirtop1 <- read.table(file, header = TRUE, sep = "\t")

data_mirtop1 <- data_mirtop1 %>%
  mutate(Total = (ref_miRNA + iso_3p + iso_5p + iso_add3p + iso_snv_seed + iso_snv_central_offset + iso_snv_central +iso_snv_central_supp),
         ref_miRNA_percentage = (ref_miRNA/Total)* 100,
         iso_3p_percentage = (iso_3p/Total)* 100,
         iso_add3p_percentgae = (iso_add3p/Total)* 100,
         iso_5p_percentage = (iso_5p/Total)* 100,
         iso_snv_seed_percentage = (iso_snv_seed/Total)* 100)

stats <- data_mirtop1 %>%
  summarise(
    Mean_ref_miRNA_percentage = mean(ref_miRNA_percentage, na.rm = TRUE),
    Mean_iso_3p_percentage = mean(iso_3p_percentage, na.rm = TRUE),
    Max_ref_miRNA_percentage = max(ref_miRNA_percentage, na.rm = TRUE),
    Min_ref_miRNA_percentage = min(ref_miRNA_percentage, na.rm = TRUE),
    Max_iso_3p_percentage = max(iso_3p_percentage, na.rm = TRUE),
    Min_iso_3p_percentage = min(iso_3p_percentage, na.rm = TRUE),
    Mean_iso_add3p_percentgae = mean(iso_add3p_percentgae, na.rm = TRUE),
    Max_iso_add3p_percentgae = max(iso_add3p_percentgae, na.rm = TRUE),
    Min_iso_add3p_percentgae = min(iso_add3p_percentgae, na.rm = TRUE), 
    Mean_iso_5p_percentage = mean(iso_5p_percentage, na.rm = TRUE),
    Max_iso_5p_percentage = max(iso_5p_percentage, na.rm = TRUE),
    Min_iso_5p_percentage = min(iso_5p_percentage, na.rm = TRUE),
    Mean_iso_snv_seed_percentage = mean(iso_snv_seed_percentage, na.rm = TRUE)
    ) 

#knitr::kable(stats_by_group,
#             col.names = c("Group", 
#                           "TM", 
#                           "TU", 
#                           "Mean M", 
#                           "Max M", 
#                           "Min M")) %>%
#  kable_styling(
#    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
#    font_size = 10.5   # Ajustar tamaño de fuente
#  ) %>%
#  row_spec(0, bold = TRUE) # Encabezado en negrita
```
```{r Table of IsomiR unique read counts }
##| tbl-cap: "Descriptive statistics of Isomir Read counts "
##| label: "tbl-isomir_read_counts"
file <- "data/mirtop_unique_read_count_plot.tsv"  
data_mirtop2 <- read.table(file, header = TRUE, sep = "\t")

data_mirtop2 <- data_mirtop2 %>%
  mutate(Total = (ref_miRNA + iso_3p + iso_5p + iso_add3p + iso_snv_seed + iso_snv_central_offset + iso_snv_central +iso_snv_central_supp),
         ref_miRNA_percentage = (ref_miRNA/Total)* 100,
         iso_3p_percentage = (iso_3p/Total)* 100,
         iso_add3p_percentgae = (iso_add3p/Total)* 100,
         iso_5p_percentage = (iso_5p/Total)* 100,
         iso_snv_central_offset_percentage = (iso_snv_central_offset/Total)* 100,
         iso_snv_central_percentage = (iso_snv_central/Total)* 100,
         iso_snv_central_supp_percentage = (iso_snv_central_supp/Total)* 100,
         iso_snv_seed_percentage = (iso_snv_seed/Total)* 100)

stats2 <- data_mirtop2 %>%
  summarise(
    Mean_ref_miRNA_percentage = mean(ref_miRNA_percentage, na.rm = TRUE),
    Max_ref_miRNA_percentage = max(ref_miRNA_percentage, na.rm = TRUE),
    Min_ref_miRNA_percentage = min(ref_miRNA_percentage, na.rm = TRUE),
    Mean_iso_3p_percentage = mean(iso_3p_percentage, na.rm = TRUE),
    Max_iso_3p_percentage = max(iso_3p_percentage, na.rm = TRUE),
    Min_iso_3p_percentage = min(iso_3p_percentage, na.rm = TRUE),
    Mean_iso_add3p_percentgae = mean(iso_add3p_percentgae, na.rm = TRUE),
    Max_iso_add3p_percentgae = max(iso_add3p_percentgae, na.rm = TRUE),
    Min_iso_add3p_percentgae = min(iso_add3p_percentgae, na.rm = TRUE), 
    Mean_iso_5p_percentage = mean(iso_5p_percentage, na.rm = TRUE),
    Max_iso_5p_percentage = max(iso_5p_percentage, na.rm = TRUE),
    Min_iso_5p_percentage = min(iso_5p_percentage, na.rm = TRUE),
    Mean_iso_snv_central_offset_percentage = mean(iso_snv_central_offset_percentage, na.rm = TRUE),
    Mean_iso_snv_central_percentage = mean(iso_snv_central_percentage, na.rm = TRUE),
    Mean_iso_snv_central_supp_percentage = mean(iso_snv_central_supp_percentage, na.rm = TRUE),
    Mean_iso_snv_seed_percentage = mean(iso_snv_seed_percentage, na.rm = TRUE),
    mean_ref_miRNA = mean(ref_miRNA, na.rm = TRUE),
    max_ref_mirna = max(ref_miRNA, na.rm = TRUE),
    min_ref_mirna = min(ref_miRNA, na.rm = TRUE)
    ) 

#knitr::kable(stats_by_group,
#             col.names = c("Group", 
#                           "TM", 
#                           "TU", 
#                           "Mean M", 
#                           "Max M", 
#                           "Min M")) %>%
#  kable_styling(
#    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
#    font_size = 10.5   # Ajustar tamaño de fuente
#  ) %>%
#  row_spec(0, bold = TRUE) # Encabezado en negrita
```
```{r Table of Mean Isomir read counts}
##| tbl-cap: "Descriptive statistics of Isomir Read counts "
##| label: "tbl-isomir_read_counts"
file <- "data/mirtop_mean_read_count_plot.tsv"  
data_mirtop3 <- read.table(file, header = TRUE, sep = "\t")

data_mirtop3 <- data_mirtop3 %>%
  mutate(Total = (ref_miRNA + iso_3p + iso_5p + iso_add3p + iso_snv_seed + iso_snv_central_offset + iso_snv_central +iso_snv_central_supp),
         ref_miRNA_percentage = (ref_miRNA/Total)* 100,
         iso_3p_percentage = (iso_3p/Total)* 100,
         iso_add3p_percentgae = (iso_add3p/Total)* 100,
         iso_5p_percentage = (iso_5p/Total)* 100,
         iso_snv_central_offset_percentage = (iso_snv_central_offset/Total)* 100,
         iso_snv_central_percentage = (iso_snv_central/Total)* 100,
         iso_snv_central_supp_percentage = (iso_snv_central_supp/Total)* 100,
         iso_snv_seed_percentage = (iso_snv_seed/Total)* 100)

stats3 <- data_mirtop3 %>%
  summarise(
    Mean_ref_miRNA_percentage = mean(ref_miRNA_percentage, na.rm = TRUE),
    Max_ref_miRNA_percentage = max(ref_miRNA_percentage, na.rm = TRUE),
    Min_ref_miRNA_percentage = min(ref_miRNA_percentage, na.rm = TRUE),
    Mean_iso_3p_percentage = mean(iso_3p_percentage, na.rm = TRUE),
    Max_iso_3p_percentage = max(iso_3p_percentage, na.rm = TRUE),
    Min_iso_3p_percentage = min(iso_3p_percentage, na.rm = TRUE),
    Mean_iso_add3p_percentgae = mean(iso_add3p_percentgae, na.rm = TRUE),
    Max_iso_add3p_percentgae = max(iso_add3p_percentgae, na.rm = TRUE),
    Min_iso_add3p_percentgae = min(iso_add3p_percentgae, na.rm = TRUE), 
    Mean_iso_5p_percentage = mean(iso_5p_percentage, na.rm = TRUE),
    Max_iso_5p_percentage = max(iso_5p_percentage, na.rm = TRUE),
    Min_iso_5p_percentage = min(iso_5p_percentage, na.rm = TRUE),
    Mean_iso_snv_central_offset_percentage = mean(iso_snv_central_offset_percentage, na.rm = TRUE),
    Mean_iso_snv_central_percentage = mean(iso_snv_central_percentage, na.rm = TRUE),
    Mean_iso_snv_central_supp_percentage = mean(iso_snv_central_supp_percentage, na.rm = TRUE),
    Mean_iso_snv_seed_percentage = mean(iso_snv_seed_percentage, na.rm = TRUE)
    
    ) 

#knitr::kable(stats_by_group,
#             col.names = c("Group", 
#                           "TM", 
#                           "TU", 
#                           "Mean M", 
#                           "Max M", 
#                           "Min M")) %>%
#  kable_styling(
#    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
#    font_size = 10.5   # Ajustar tamaño de fuente
#  ) %>%
#  row_spec(0, bold = TRUE) # Encabezado en negrita
```

## Differential expression analysis
```{r Libraries , message=FALSE, echo=FALSE}
library("isomiRs")
library("readr")
library("tibble")
library("pheatmap")
library("dplyr")
library("ggplot2")
library("DESeq2")
library("kableExtra")
library("ggpubr")
library("compareGroups")
library("tidyr")
library("org.Mm.eg.db")
library("clusterProfiler")
library("tibble")
library("knitr")
library("ashr")
```
```{r Data of Isomirs, message=FALSE, echo=FALSE}
setwd("~/Documentos/TFM/mirna_analysis/miRNA/TFM")
  # Steatosis 
  # Count matrix
countdata <- read_csv("/home/joshoacr13/Documentos/TFM/mirna_analysis/input/20241105-countdata.csv")
  # Metadata matrix
load("/home/joshoacr13/Documentos/TFM/mirna_analysis/input/20241105_metadata_steatosis.Rdata")

# Usar IsomirDataSeqFromMirtop
# mirna_data_steatosis <- IsomirDataSeqFromMirtop(mirtop = countdata_complete, coldata = mdata_steatosis)
#mirna_data_steatosis <- IsomirDataSeqFromMirtop(mirtop = countdata, coldata = mdata_steatosis)

load("/home/joshoacr13/Documentos/TFM/mirna_analysis/input/21112024_mirna_data_steatosis.Rdata")
```
```{r ids counts, fig.width=8, fig.height=4, fig.pos="H"}
# Cuentas con los miRNA de referencia
mdata_steatosis_hm <- mdata_steatosis
colnames(mdata_steatosis_hm) <- c("sex", "Steatosis", "Steatosis_3", "Steatosis_2")
mdata_steatosis_hm$sex[mdata_steatosis_hm$sex == "hombre"] <-"male"
mdata_steatosis_hm$sex[mdata_steatosis_hm$sex == "mujer"] <-"female"

# Usar IsomirDataSeqFromMirtop
#mirna_data_steatosis_heatmap <- IsomirDataSeqFromMirtop(mirtop = countdata, coldata = mdata_steatosis_hm)

#save(mirna_data_steatosis_heatmap, file = "data/miRNA_heatmap.RData")

load("data/miRNA_heatmap.RData")
ids_counts <- isoCounts(mirna_data_steatosis_heatmap, minc = 20, mins = 40)
# Plot
##| fig-cap: "fig-isomiRsAbundance"
##| out-width: "15cm"
#isoPlot(ids_counts,type="all")
#title(xlab = "Unique Identifier", ylab = "Percentage of Relative Abundance")
```
Differential expression analysis is a bioinformatics and statistical technique used to identify genes, proteins, or other biomolecules that exhibit significant differences in expression levels between two or more biological conditions. For this analysis, the sequences of miRNAs of reference were used, as annotated in the previous analysis.

Under the hood of *DESeq2*, we applied the *regularized logarithm* (*rlog*) transformation for normalization, which incorporates a prior on the sample differences [@love2014moderated]. This step is crucial because the standard logarithmic transformation can be sensitive to low expression values, whereas *rlog* addresses this issue by introducing regularization that helps stabilize variability between samples. This method facilitates seamless integration into subsequent analyses, as demonstrated in [@fig-heatmap], which shows a total of 374 miRNAs were found to be expressed differentially in the overall cohort when patients (samples) were categorized by sex and steatosis.

Since we were primarily interested in the transcriptional changes that may precede the initiation of the steatosis process, we focused on contrasting individuals across different levels of steatosis. In this experimental scenario, the goal is to identify miRNAs that are expressed differentially at various levels of steatosis. In our differential expression analysis using *DESeq2* with the LRT model, we initially identified 169 miRNAs as upregulated and 205 downregulated in the subcutaneous white adipose tissue (scWAT) of individuals according their steatosis degree. Comparing these four groups and applying a false discovery rate (FDR) cutoff of less than 0.05, the number of statistically siginificant differentially expressed miRNAs was greatly reduced to 2 ([@fig-volcan]). Of these, we found *hsa-miR-372-3p* is upregulated and *hsa-miR-144-3p* is downregulated ([@tbl-mirnas_selected]).

```{r DESIGN + DESEQMATRIX, fig.width=8, fig.height=4, fig.pos="H"}
## DESIGNS
  # Reduced
reduced_design=model.matrix( ~ sexo, data=mdata_steatosis)

  # Complete
complete_design=model.matrix( ~ sexo + Esteatosis,data=mdata_steatosis)

# Ajustar el Modelo Completo
dds <- DESeqDataSetFromMatrix(countData = counts(ids_counts),
                              colData = colData(ids_counts),
                              design = complete_design)

# Ajustar modelo reducido (sin 'steatosis')
dds_1 <- DESeq(dds, test = "LRT", reduced = reduced_design)

# Obtener los Resultados
resultsLRT <- results(dds_1, pAdjustMethod = "fdr", independentFiltering = TRUE)

# Apply the filter of 0.05 (FDR)
resultsLRT_df <- resultsLRT |>
  as.data.frame()

r_sc <- resultsLRT_df |> 
  filter(padj < 0.05)

# Count up and down regulated
up <- sum(resultsLRT_df$log2FoldChange > 0, na.rm = TRUE)
dowm <- sum(resultsLRT_df$log2FoldChange < 0, na.rm = TRUE) 

# Filtrar resultados significativos
significant_isomiRs <- resultsLRT[resultsLRT$padj < 0.05, ]  # Estricto
```

```{r}
counts_sc <- dds@assays@data$counts |> 
  as.data.frame() |> 
  # Move gene names into a column named "gene"
  rownames_to_column("miRNA") |> 
  # Reshape the data from wide to long format with gene, sample, and counts columns
  pivot_longer(-"miRNA", names_to = "sample", values_to = "counts") |> 
  # Join the counts data with metadata to add sample information
  inner_join(mdata_steatosis |> rownames_to_column("prefix"), by = c("sample" = "prefix")) |> 
  # Ensure sample names are treated as characters
  mutate(sample = as.character(sample))

# Function for boxplot decoration
gg_box <- function() {
  list(
    # Add a boxplot geometry, remove missing values (na.rm = TRUE)
    geom_boxplot(na.rm = TRUE),
    # Apply a log2 transformation to the y-axis
    scale_y_continuous(trans = "log2"),
    # Add labels for the x and y axes
    labs(x = "\nSample", y = "Raw counts"),
    # Set custom fill colors for steatosis categories
    scale_fill_manual("Steatosis", values = c("#99c140", "#e7b416", "#db7b2b","red")),
    # Flip the coordinates to make the boxplots horizontal
    coord_flip(),
    # Apply a minimal theme for a clean appearance
    theme_minimal(),
    # Adjust the size of the axis titles
    theme(axis.title = element_text(size = 14))
  )
}

# Boxplot visualizing the log-transformed read counts across samples grouped by steatosis categories
p1 <- ggplot(counts_sc, aes(x = reorder(sample, as.numeric(Esteatosis)),
                            # Add 1 to counts for log transformation, and fill by steatosis category
                            y = counts + 1, fill = Esteatosis)) +
      # Apply the gg_box function for consistent styling
      gg_box()
```

```{r}
vst_sc <- vst(dds, nsub = nrow(dds))

# Calculate PCA for scWAT data using "sexo" and "steatosis_3cat" as factors, return PCA data
pca_data_sc <- plotPCA(vst_sc, c("sex", "Steatosis"), returnData = TRUE)   

# Calculate and round the percentage of variance explained by the first two principal components (PC1 and PC2)
percentVar <- round(100 * attr(pca_data_sc, "percentVar"))    

# Create a scatter plot for the first two principal components (PC1 and PC2) for scWAT data
p3 <- ggplot(pca_data_sc, aes(PC1, PC2, color = Steatosis, shape = sex)) +
  geom_point(size = 3) +   
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +  
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +   
  coord_fixed() +    # Set aspect ratio to be equal
  scale_color_manual("Steatosis", values = c("#99c140","#e7b416","#db7b2b","red")) +   
  theme_minimal() +  
  theme(legend.position = "none")    # Hide legend

#print(p3)
```

```{r, table of mirnas selected}
#| tbl-cap: "Differentially expressed miRNAs in subcutaneous white adipose tissue (scWAT). *FDR* : False Discovery Rate"
#| label: "tbl-mirnas_selected"
# Subset the LRT results to return genes with padj < 0.05

table_mirnas <- resultsLRT_df %>%
  data.frame() %>%
  rownames_to_column(var="row") %>%
  as_tibble() %>% 
  filter(padj < 0.05) %>%
  mutate(
    baseMean = round(baseMean, 3),
    log2FoldChange = round(log2FoldChange, 3),
    lfcSE = round(lfcSE, 3),
    stat = round(stat, 3),
    pvalue = case_when(
      pvalue < 0.000215 ~ "p< 0.0002",
      TRUE ~ as.character(pvalue)),
    padj = round(padj,3)
  ) %>% 
  select("row","log2FoldChange","pvalue", "padj")

knitr::kable(table_mirnas,
             col.names = c("", 
                              "log2FoldChange",
                           "pvalue", "FDR"),)%>%
  kable_styling(
    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
    font_size = 11   # Ajustar tamaño de fuente
  ) %>%
  row_spec(0, bold = TRUE) # Encabezado en negrita

```

```{r fig-volcan, fig.width=5, fig.height=2.5, fig.pos="H", fig.cap="Plot showing differentially expressed miRNAs (red) in subcutaneous white adipose tissue (scWAT) according to the four groups of steatosis"}
# Visualizar resultados
#| label: fig-volcan
#| fig-cap: "Plot showing differentially expressed miRNAs (red) in subcutaneous white adipose tissue (scWAT) according to the four groups of steatosis"

resultsLRT <- results(dds_1, tidy = TRUE)

data <- data.frame(
  miRNA= resultsLRT$row,
  log2FoldChange = resultsLRT$log2FoldChange,
  pvalue = resultsLRT$pvalue,
  padj = resultsLRT$padj
)

# Crear la visualización
ggplot(data, aes(x = log2FoldChange, y = -log10(pvalue))) +
  geom_point(aes(color = padj < 0.05), size = 1) +  # Puntos
  geom_text_repel(
    data = subset(data, padj < 0.05),
    aes(label = miRNA),                             # Etiquetas con nombres de miRNA
    box.padding = 0.35,                             # Espaciado alrededor de las etiquetas
    point.padding = 0.3,                            # Espaciado respecto al punto
    segment.color = "gray",                         # Color de las líneas
    max.overlaps = Inf,
    size = 2
  ) +
  scale_color_manual(values = c("TRUE" = "darkred", "FALSE" = "darkgreen")) +
  geom_hline(yintercept = 0, color = "black", linetype = "solid", size = 0.5) +  # Línea horizontal en y = 0
  geom_vline(xintercept = 0, color = "black", linetype = "dashed", size = 0.5) +
  geom_vline(xintercept = -4, color = "black", linetype = "solid", size = 0.5) +
  scale_x_continuous(limits = c(-4, 2)) +  # Límites del eje x
  
  labs(
    x = "Log2 Fold Change",
    y = "-Log10 (P-value)",
    color = "Significant"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 0 , hjust = 1, size = 7),
    axis.text.y = element_text(angle = 0 , hjust = 1, size = 7),
    axis.title.x = element_text(size = 11),
    axis.title.y = element_text(size = 11),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "none",
    legend.margin = margin(t = -20) # Ajusta el margen superior de la leyenda
#    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)
)


```


```{r fig-dispersion ,fig.width=8, fig.height=4, fig.pos="H"}
##| fig-cap: "Estimation of the dispersion "
##| label: fig-disp
#dds_est <- estimateDispersions(dds_1)
#plotDispEsts(dds_est)
```

\clearpage

```{r fig-heatmap, fig.width=12, fig.height=12, fig.pos="H", fig.cap="The heatmap illustrates the expression of 374 individual miRNA sequences across the analyzed samples. In this visualization, shades of red indicate increased miRNA expression, whereas shades of blue denote reduced or absent miRNA expression. Although a substantial number of miRNAs were identified, no distinct grouping patterns emerged among the analyzed samples, suggesting heterogeneity in miRNA expression profiles across the dataset."}
# Visualizar resultados
#| label: fig-heatmap
#| fig-cap: "The heatmap displays all miRNA data (374) across all samples. In the heatmap, shades of red represent increased miRNA expression, while shades of blue signify reduced or absent miRNA expression. Despite the identification of numerous miRNAs, no clear grouping patterns were observed across the samples."

library(pheatmap)
ids = isoNorm(ids_counts, formula =  ~ sex + Steatosis)
pheatmap(counts(ids, norm=TRUE)[1:374,], 
         annotation_col = data.frame(colData(ids)[,c(1:2),drop=FALSE]),
         show_rownames = FALSE, scale="row")
```

\clearpage

Following their identification, we further analyzed the expression patterns of these two differentially expressed miRNAs by representing their normalized counts in boxplots across the four steatosis groups [@fig-mirnasselected].The boxplots highlight the consistency of expression changes across groups, reinforcing the relevance of these miRNAs in the context of steatosis severity. The miRNA *hsa-miR-144-3p* pattern of expression a significant decrease in expression as steatosis levels increase, whereas *hsa-miR-372-3p* exhibits a trend of progressively higher expression across the varying levels of steatosis.

Despite observing a trend of increasing expression of *hsa-miR-372-3p* with rising levels of steatosis, the results from the Kruskal-Wallis test did not achieve statistical significance (*p*= 0.28) when comparing the different states of steatosis. This suggests that, while there may be a tendency towards increased expression of the miRNA with the progression of steatosis, a larger sample size or an alternative approach is needed to draw firmer conclusions about its role in the progression of the disease.

```{r fig-mirnasselected,fig.width=8, fig.height=4, fig.pos="H", fig.cap= "Boxplots of the differentially expressed miRNAs in subcutaneous white adipose tissue (scWAT) according to the four groups of steatosis. Each box represents the interquartile range (IQR) of the normalized counts, with the line inside the box indicating the median. The whiskers extend to show the range of the data, excluding outliers, which are displayed as individual points. *p*: p-value fot the Kruskal–Wallis test for the comparison between groups."}
# Visualizar resultados
#| label: fig-mirnasselected
#| fig-cap: "Boxplots of the differentially expressed miRNAs in subcutaneous white adipose tissue (scWAT) according to the four groups of steatosis. Each box represents the interquartile range (IQR) of the normalized counts, with the line inside the box indicating the median. The whiskers extend to show the range of the data, excluding outliers, which are displayed as individual points."

# Normalize the counts for scWAT data and transpose the matrix7
dds_1 <- DESeq(dds, test = "LRT", reduced = reduced_design)

# Normalize the metadata for scWAT to match the normalized counts
counts_norm_sc <- t(counts(dds_1, norm=T))

# Subset the metadata for scWAT to match the normalized counts
meta_data_sc <- mdata_steatosis[rownames(counts_norm_sc), c("sexo", "Esteatosis")]
meta_data_sc <- meta_data_sc %>%
  mutate(
    Esteatosis = case_when(
      Esteatosis == 0 ~ "<5%",
      Esteatosis == 1 ~ "5–33%",
      Esteatosis == 2 ~ "33–66%",
      Esteatosis == 3 ~ ">66%",
      TRUE ~ as.character(Esteatosis) # Para manejar otros casos
    )
  )

meta_data_sc <- meta_data_sc %>%
  mutate(
    Esteatosis = factor(Esteatosis, levels = c("<5%", "5–33%", "33–66%", ">66%"))
  )


    # Combining normaized data with metadata
sc <- as.data.frame(counts_norm_sc) |>
  # Select columns corresponding to the miRNAs identified in scWAT
  select(rownames(r_sc)) |>
  # Bind the selected miRNAs with the corresponding metadata
  bind_cols(meta_data_sc) |>
  # Reshape the data to long format for ggplot, with miRNA and Normalized Counts
  pivot_longer(1:nrow(r_sc), names_to = "miRNA", values_to = "Normalized Counts")|>
  # Add 1 to avoid infinity in the log scale
  mutate(`Normalized Counts`=`Normalized Counts` +1)

gg_miRNA <- function() {
  list(
    scale_y_continuous(trans = "log2"),
    labs(x="\nSteatosis"),
    geom_boxplot(width= 0.5, outliers = FALSE),
    geom_jitter(width = 0.25, size= 2, alpha = 0.3),
    geom_smooth(aes(group = 1), method = "lm", color = "#8c8c8c", se = FALSE), 
    stat_compare_means(aes(label= paste0("p= ", ..p.format..)),
                       method = "kruskal.test",
                       label.x.npc = 0.3,
                       label.y.npc = 0.8,
                       size = 4),
    theme_minimal(),
    scale_fill_viridis_d(),  # Para los rellenos
    facet_wrap(facets = ~miRNA, scales = "free_y", ncol=4),
    theme(legend.position = "none",
          strip.text = element_text(size = 13),
          axis.title = element_text(size = 13),
          axis.text.y = element_text(size = 11),
          axis.text.x = element_text(size = 12),
          strip.text.x = element_text(face = "italic")
          )
  )
}

ggplot(sc, aes(x= Esteatosis, y =`Normalized Counts`, fill= Esteatosis)) + gg_miRNA()
```

## Target mRNA Selection and Validation
### *hsa-miR-372-3p*
Potential target genes of the selected miRNAs were identified using the *multiMiR* package. This analysis included only validated interaction data, ensuring the biological relevance of the identified mRNAs. A subsequent filtering process was applied to select targets based on the type of experimental validation (e.g., luciferase assays, Western blot, or qRT-PCR) and functional support. As shown in [@tbl-hsa-miR-372-3p], 24 target genes were identified after filtering.

```{r libraries targer, echo=FALSE, warning=FALSE, message=FALSE}
#library("multiMiR")
library("kableExtra")
library("dplyr")
library("ggplot2") # Para visualización (opcional)
library("clusterProfiler") # Para análisis funcional (opcional)
library("org.Hs.eg.db") # Base de datos de genes humanos
library("rentrez")
library("KEGGREST")
```
```{r}
#val_hsa_miR_372_3p <- get_multimir(org = "hsa", mirna = 'hsa-miR-372-3p', table = "validated", add.link = TRUE, use.tibble = TRUE, summary = TRUE)

# Check which types of associations were returned
#table(val_hsa_miR_372_3p@data$type)
#dim(val_hsa_miR_372_3p@data)

# Detailed information of the validated miRNA-target interaction
#head(val_hsa_miR_372_3p@data)


# Extraer los datos como un data.frame o tibble
#val_hsa_miR_372_3p_df <- as_tibble(val_hsa_miR_372_3p@data)

# Guardar el data.frame en un archivo .RData
#save(val_hsa_miR_372_3p_df, file = "data/val_hsa_miR_372_3p.RData")
```
```{r tbl-hsa-miR-372-3p}
#| tbl-cap: "Selected interactions after filtering by database, experiment type (including luciferase assays, Western blot, or qRT-PCR), functional support (Functional MTI) and validated type for *hsa-miR-372-3p*."
#| label: "tbl-hsa-miR-372-3p"

# Load the target genes for hsa-miR-372-3p
load("/home/joshoacr13/Documentos/TFM/mirna_analysis/miRNA/TFM/data/val_hsa_miR_372_3p.RData")

# Filtrar los datos con las condiciones especificadas
filter_val_hsa_miR_372_3p <- val_hsa_miR_372_3p_df[
  val_hsa_miR_372_3p_df[["database"]] %in% c("mirtarbase", "tarbase") & 
  grepl("Luciferase|Western blot|qRT-PCR", val_hsa_miR_372_3p_df[["experiment"]], ignore.case = TRUE) &  # Filtro por experimentos específicos
  val_hsa_miR_372_3p_df[["support_type"]] %in% c("Functional MTI","Functional MTI (Weak)","") &  # Filtro por soporte funcional
  val_hsa_miR_372_3p_df[["type"]] == "validated", # Filtro por tipo validado
]

# Eliminar algunas columnas
filter_val_hsa_miR_372_3p_edit <- as.data.frame(filter_val_hsa_miR_372_3p) %>%
  dplyr::select(-database,-mature_mirna_id,-pubmed_id,-mature_mirna_acc,-DB.link,-target_entrez,-experiment,-support_type, -type) 

# Eliminar algunas filas
filter_val_hsa_miR_372_3p_edit <- filter_val_hsa_miR_372_3p_edit[-c(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 17, 18, 20, 21, 22, 24, 26, 28, 29, 31, 32, 34, 35, 36, 38, 40, 42, 43, 44, 46, 47, 49, 50, 52, 53, 55, 57, 59, 61, 62, 65, 68, 69, 70, 71, 72, 74, 75), ]

### TABLE

knitr::kable(filter_val_hsa_miR_372_3p_edit,
             col.names = c("Gene", "Ensembl Identifier"),
             row.names = FALSE) %>%
  kable_styling(
    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
    font_size = 11   # Ajustar tamaño de fuente
  ) %>%
  row_spec(0, bold = TRUE) # Encabezado en negrita

```

The target genes identified through *multiMiR* were subjected to functional enrichment analysis using KEGG (Kyoto Encyclopedia of Genes and Genomes) pathways [@KEGG]. The KEGG pathway enrichment analysis identified five significantly enriched pathways (p < 0.05) ([@fig-enrichment_hsamiR_372_3p]). The most prominent pathways include:

- *Cellular senescence* (KEGG ID: hsa04218): associated with cellular aging and the permanent arrest of the cell cycle in response to genetic damage, oxidative stress, or oncogenic signals.
- *Cell cycle* (KEGG ID: hsa04110): involved in the regulation and progression of the cell cycle, including critical checkpoints that ensure the fidelity of cell division.
- *Hepatitis B* (KEGG ID: hsa05161): related to infection by the hepatitis B virus and the inflammatory and carcinogenic processes it can trigger in the liver.
- *PI3K-Akt signaling pathway* (KEGG ID: hsa04151): a key pathway regulating cellular processes such as proliferation, survival, and metabolism, frequently deregulated in cancer. This pathway is related with insuline resistence.
- *Pancreatic cancer* (KEGG ID: hsa05212): associated with molecular and cellular alterations characteristic of this cancer type, including aberrant signaling and apoptosis resistance.

These pathways are primarily linked to essential processes such as *cell cycle regulation*, *intracellular signaling in cancer*, and *cellular responses to damage and infection*.

```{r KEGG Gene ontology, warning=FALSE, echo=FALSE, message=FALSE}
# Gene Entrez para todos los genes combinados
gene_symbols_hsa_miR_372_3p_validated <- filter_val_hsa_miR_372_3p$target_entrez%>% unique()
# Realizar análisis de enriquecimiento
#enrich_result_hsa_miR_372_3p <- enrichKEGG(gene = gene_symbols_hsa_miR_372_3p_validated, organism = "hsa", pvalueCutoff = 0.05)

# Guardar el data.frame en un archivo .RData
#save(enrich_result_hsa_miR_372_3p, file = "data/KEGG_hsa_miR_372_3p.RData")
```
```{r fig-enrichment_hsamiR_372_3p,  fig.width=8, fig.height=2.5, fig.pos="H",fig.cap="Top 5 Significant KEGG Pathways of *hsa-miR-372-3p*"}
# Visualizar resultados
#| label: fig-enrichment_hsamiR_372_3p
#| fig-cap: "Top 5 Validated Enriched Biological Processes of *hsa-miR-372-3p* "
# t_372 <- enrich_result_hsa_miR_372_3p@result
load("data/KEGG_hsa_miR_372_3p.RData")
barplot(enrich_result_hsa_miR_372_3p, showCategory = 5)
```

### *hsa-miR-144-3p*
[@tbl-hsa-miR-144-3p] shows 22 target genes were identified for *hsa-miR-372-3p*, filtered by validated interactions and experimental evidence.

```{r ,  echo=FALSE, warning=FALSE}
# The default is to search validated interactions in human
#val_hsa_miR_144_3p <- get_multimir(org = "hsa",
#                                mirna = 'hsa-miR-144-3p',
#                                table = "validated",
#                                add.link = TRUE,
#                                use.tibble = TRUE,
#                               summary = TRUE)

# Extraer los datos como un data.frame o tibble
#val_hsa_miR_144_3p_df <- as_tibble(val_hsa_miR_144_3p@data)

# Guardar el data.frame en un archivo .RData
#save(val_hsa_miR_144_3p_df, file = "data/val_hsa_miR_144_3p.RData")
```
```{r tbl-hsa-miR-144-3p, echo=FALSE, warning=FALSE}
#| tbl-cap: "Selected interactions after filtering by database, experiment type (including luciferase assays, Western blot, or qRT-PCR), functional support (Functional MTI) and validated type for *hsa-miR-144-3p*."
#| label: "tbl-hsa-miR-144-3p"

load("/home/joshoacr13/Documentos/TFM/mirna_analysis/miRNA/TFM/data/val_hsa_miR_144_3p.RData")

# Filtrar los datos con las condiciones especificadas
filter_val_hsa_miR_144_3p <- val_hsa_miR_144_3p_df[
  #  val_hsa_miR_144_3p_df[["database"]] %in% c("mirtarbase", "tarbase") &  # Filtrar por bases de datos específicas
  grepl("Luciferase|Western blot|qRT-PCR", val_hsa_miR_144_3p_df[["experiment"]], ignore.case = TRUE) &  # Filtro por experimentos específicos
    val_hsa_miR_144_3p_df[["support_type"]] %in% c("Functional MTI","Functional MTI (Weak)") &  # Filtro por soporte funcional
    val_hsa_miR_144_3p_df[["type"]] == "validated", # Filtro por tipo validado
]

# Eliminar algunas columnas
filter_val_hsa_miR_144_3p_edit <- as.data.frame(filter_val_hsa_miR_144_3p) %>%
  dplyr::select(-database,-mature_mirna_id,-pubmed_id,-mature_mirna_acc,-DB.link,-target_entrez,-experiment,-support_type,-type) 

# Eliminar algunas filas
filter_val_hsa_miR_144_3p_edit <- filter_val_hsa_miR_144_3p_edit[-c(2,12,18,19,22,27), ]

### TABLE

knitr::kable(filter_val_hsa_miR_144_3p_edit,
             col.names = c("Gene", "Ensembl Identifier"),
             row.names = FALSE) %>%
  kable_styling(
    latex_options = c("hold_position", "scale_down"), # Escala automáticamente
    font_size = 11   # Ajustar tamaño de fuente
  ) %>%
  row_spec(0, bold = TRUE) # Encabezado en negrita
```

The target genes identified through *multiMiR* were subjected to functional enrichment analysis using KEGG where five significantly enriched pathways (p < 0.05) ([@fig-enrichment_hsamiR_144_3p]). The most prominent pathways include:

- *MicroRNAs in cancer* (KEGG ID: hsa05206): Highlighting the role of miRNAs in the regulation of gene expression, particularly in pathways associated with tumorigenesis and cancer progression.  
- *Hepatocellular carcinoma* (KEGG ID: hsa05225): Specifically linked to liver cancer and the molecular mechanisms underlying its development and progression.  
- *FoxO signaling pathway* (KEGG ID: hsa04068): A critical pathway regulating oxidative stress response, apoptosis, and metabolism, which plays a significant role in cancer and aging.  
- *Gastric cancer* (KEGG ID: hsa05226): Associated with molecular and cellular alterations characteristic of gastric tumorigenesis.  
- *Cellular senescence* (KEGG ID: hsa04218): Related to aging and the permanent arrest of the cell cycle due to stress signals or damage.  

```{r KEGG gene ontology, fig.width=8, fig.height=2.5, fig.pos="H"}
# Gene Ontology (GO) para todos los genes combinados
gene_symbols_miR_144_3p_validated <- filter_val_hsa_miR_144_3p$target_entrez %>% unique()

# Realizar análisis de enriquecimiento
#enrich_result_hsa_miR_144_3p <- enrichKEGG(gene = gene_symbols_miR_144_3p_validated, organism = "hsa", pvalueCutoff = 0.05)

# Guardar el data.frame en un archivo .RData
#save(enrich_result_hsa_miR_144_3p, file = "data/KEGG_hsa_miR_144_3p.RData")
```
```{r fig-enrichment_hsamiR_144_3p,  fig.width=8, fig.height=3, fig.pos="H",fig.cap="Top 5 Significant KEGG Pathways of *hsa-miR-144-3p*"}
# Visualizar resultados
#| label: fig-enrichment_hsamiR_144_3p
#| fig-cap: "Top 5 Validated Enriched Biological Processes of *hsa-miR-144-3p* "
#| 
load("data/KEGG_hsa_miR_144_3p.RData")
barplot(enrich_result_hsa_miR_144_3p, showCategory = 5)
```

These pathways reflect key biological processes, including tumorigenesis, stress response, and cell cycle regulation, underscoring the importance of miRNAs in these mechanisms. The findings provide valuable insights into potential molecular interactions and pathways relevant to the studied system.

## The *hsa-miR-372-3p* and *hsa-miR-144-3p* in an in vitro model of lipid steatosis.

The gene expression was evaluated in HepG2 cells transfected for 24 hours and then treated with Oleic Acid (OA) for an additional 24 hours to assess the impact of single miRNA in a cell model mimicking hepatic steatosis. Specifically, we investigated the relative expression of *PPARG* (Peroxisome Proliferator Activated Receptor Gamma), a key regulator of adipogenesis and insulin sensitivity; *PNPLA2* (Patatin Like Phospholipase Domain Containing 2), which encodes the Adipose Triglyceride Lipase (*ATGL*) involved in triglyceride breakdown; *DGAT2* (Diacylglycerol O-Acyltransferase 2), a critical enzyme for triglyceride synthesis; *FAS* (Fas Cell Surface Death Receptor), a mediator of apoptosis and cellular stress; and *ACACA* (Acetyl-CoA Carboxylase Alpha), the rate-limiting enzyme in *de novo* fatty acid synthesis. These genes play pivotal roles in lipid metabolism and, to a lesser extent, glucose metabolism, making them relevant targets for understanding the molecular mechanisms underlying hepatic steatosis.

The synthetic *miR-372* mimic significantly downregulated the mRNA expression of the gene *ACAC* (-91.40% ± 3.39; p < 0.05) in OA-treated HepG2 cells. A similar, although not statistically significant, decrease was observed in the mRNA levels of *FAS* (-90.50% ± 4.30; p < 0.093), suggesting a trend towards reduced expression. In contrast, the mRNA levels of *DGAT2* (-73.7% ± 6.70; p = 0.462) and *PNPLA2* (-55.10% ± 19.56; p = 0.243) did not show significant changes. Notably, the mRNA levels of *PPARG* remained unchanged compared to the negative control cells ([@fig-rge_mir372]).



```{r fig-rge_mir372, fig.width=5.3, fig.height=5.5, fig.pos="H", fig.cap= "Gene expression analysis of HepG2 cells transfected with *miR-372-3p* mimic and negative control (scramble sequence) were treated with oleic acid to mimic in vitro hepatic steatosis.", results='asis', message=FALSE, warning=FALSE}
# Visualizar resultados
#| label: fig-rge_mir372

# Librerías necesarias
library(ggplot2)
library(viridis)
library(ggtext)

mimic <- data.frame(
  GENE = c("PPARG", "PPARG", "PNPLA2", "PNPLA2", "DGAT2", "DGAT2", "FAS", "FAS", "ACCA", "ACCA"),
  REP = c("NC + OA", "hsa-miR-372-3p + OA", "NC + OA", "hsa-miR-372-3p + OA", 
          "NC + OA", "hsa-miR-372-3p + OA", "NC + OA", "hsa-miR-372-3p + OA", 
          "NC + OA", "hsa-miR-372-3p + OA"),
  FC_mean = c(1.000, 0.882, 1.000, 0.449, 1.000, 0.263, 1.000, 0.095, 1.000, 0.086),
  SE_mean = c(0.0253649433, 0.1730882558, 0.6437671279, 0.195646384, 
              0.4281888365, 0.06709488689, 0.2673172806, 0.04301184996, 
              0.1394592763, 0.03397368331),
  t_test = c(NA, 0.5879978158, NA, 0.2430561613, NA, 0.4627613518, NA , 0.09374163982, NA, 0.02952105718)
)

# Verifica y convierte las columnas a numérico si es necesario
mimic$REP <- factor(mimic$REP, levels = c("NC + OA", "hsa-miR-372-3p + OA"))

# Define el factor para GENE con el orden deseado
mimic$GENE <- factor(mimic$GENE, levels = sort(unique(mimic$GENE)))

library(ggplot2)
library(viridis)
library(ggtext)

# Crear el gráfico con saltos de línea usando <br>
ggplot(mimic, aes(x = GENE, y = FC_mean, fill = REP)) +
  geom_bar(stat = "identity", position = position_dodge(), color = "black") +
  geom_errorbar(aes(ymin = FC_mean - SE_mean, ymax = FC_mean + SE_mean), 
                width = 0.2, position = position_dodge(0.9)) +
  labs(
    title = "",
    x = "",
    y = "Relative gene expression\n Fold change",
    caption = "<b>Description:</b> The mRNA levels of protein-coding genes <i>ACCA, DGAT2, FAS, PNPLA2,PPARG</i>, involved<br>
    in glucose and lipid metabolism, were assessed. HepG2 cells were transfected with 50 nM of mirVana  <br> 
    mimic <i>miR-372-3p</i> (5'-AAAGUGCUGCGACAUUUGAGCGU-3') along with a randomized sequence as  <br>
    control (Negative Control 1). Twenty-four hours post-transfection, cells were treated with oleic acid  <br>
    (0.5 mM) for 24 hours. Results are mean relative gene expression ± SEM (n = 3).<br>
    <b>Abbreviations:</b> <i>NC</i> (negative control), <i>OA</i> (Oleic Acid), <i>ACCA</i> (Acetyl-CoA Carboxylase Alpha), <i>DGAT2</i> <br> 
    (Diacylglycerol O-Acyltransferase 2), <i>FAS</i> (Fatty Acid Synthase), <i>PNPLA2</i> (Patatin-like phospholipase  <br> 
    domain-containing protein 2), <i>PPARG</i> (Peroxisome Proliferator Activated Receptor Gamma).<br>
    <i>p</i>-value: * <i>p</i> < 0.05."
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1, size = 10, face = "italic"),
    axis.text.y = element_text(angle = 0 , hjust = 1, size = 10),
    axis.title = element_text(size = 11),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    plot.caption = ggtext::element_markdown(size = 7, hjust = 0)
  ) +
  scale_fill_manual(values = c("NC + OA" = "#FFD700", "hsa-miR-372-3p + OA" = "#440154FF")) +
  scale_y_continuous(limits = c(0, 2)) +
  geom_text(aes(label = ifelse(!is.na(t_test) & t_test < 0.05, "*", "")), 
            position = position_dodge(0.9), vjust = -0.5, size = 5)

```
On the other hand, inhibition of *hsa-miR-144-3p* upregulated the expression of the genes involved in lipid metabolism.. The relative gene expression levels of the evaluated targets in HepG2 cells transfected and treated with Oleic Acid (OA) were as follows: *ACACA* (96.80% ± 53.79; p = 0.186), *FAS* (135% ± 160.34; p = 0.429), *DGAT2* (32.74% ± 24.13; p = 0.128), *PNPLA2* (48.83% ± 14.32; p = 0.140), and *PPARG* (64.09% ± 41.25; p = 0.239) ([@fig-rge_mir372]). Although the expression levels varied across genes, none of these changes were statistically significant (p > 0.05). These findings suggest that the regulatory effect of *hsa-miR-144-3p* on these genes may be limited under the experimental conditions employed.

```{r fig-rge_mir144,fig.width=5.3, fig.height=5.5, fig.pos="H", fig.cap= "Gene expression analysis of HepG2 cells transfected with *miR-144-3p* inhibitor and negative control (scramble sequence) were treated with oleic acid to mimic in vitro hepatic steatosis.", results='asis', message=FALSE, warning=FALSE}
# Visualizar resultados
#| label: fig-rge_mir144
#| fig-cap: ""

library(ggplot2)
library(viridis)
library(ggtext)

# Crear el data frame
inhibitor <- data.frame(
  GENE = c("PPARG", "PPARG", "PNPLA2", "PNPLA2", "DGAT2", "DGAT2", "FAS", "FAS", "ACCA", "ACCA"),
  REP = c("NC + OA", "hsa-miR-144-3p + OA", "NC + OA", "hsa-miR-144-3p + OA", "NC + OA", "hsa-miR-144-3p + OA", "NC + OA", "hsa-miR-144-3p + OA", "NC + OA", "hsa-miR-144-3p + OA"),
  FC_mean = c(1.000, 1.641, 1.000, 1.488, 1.000, 1.327, 1.000, 2.355, 1.000, 1.968),
  SE_mean = c(0.03237991825, 0.4125939848, 0.08949706471, 0.1432962144, 0.06603823342, 0.2413696664, 0.1809872273, 1.603433212, 0.2222914562, 0.5379133643),
  t_test = c(NA, 0.2399930204, NA, 0.1408124422, NA, 0.1287062658, NA , 0.4294512701, NA, 0.186294657)
)

# Asegúrate de que las columnas sean factores
inhibitor$REP <- factor(inhibitor$REP, levels = c("NC + OA", "hsa-miR-144-3p + OA"))

# Define el factor para GENE con el orden deseado
inhibitor$GENE <- factor(inhibitor$GENE, levels = sort(unique(inhibitor$GENE)))

# Crear el gráfico
ggplot(inhibitor, aes(x = GENE, y = FC_mean, fill = REP)) +
  geom_bar(stat = "identity", position = position_dodge(), color = "black") +
  geom_errorbar(aes(ymin = FC_mean - SE_mean, ymax = FC_mean + SE_mean), 
                width = 0.2, position = position_dodge(0.9)) +
  labs(title = "",
       x = "",
       y = "Relative gene expression \n Fold change",
       caption = "<b>Description:</b> The mRNA levels of protein-coding genes <i>ACCA, DGAT2, FAS, PNPLA2,PPARG</i>, involved<br>
    in glucose and lipid metabolism, were assessed. HepG2 cells were transfected with 50 nM of mirVana  <br> 
    mimic <i>mmiR-144-3p</i> (5'-UACAGUAUAGAUGAUGUACU-3') along with a randomized sequence as  <br>
    control (Negative Control 1). Twenty-four hours post-transfection, cells were treated with oleic acid  <br>
    (0.5 mM) for 24 hours. Results are mean relative gene expression ± SEM (n = 3).<br>
    <b>Abbreviations:</b> <i>NC</i> (negative control), <i>OA</i> (Oleic Acid), <i>ACCA</i> (Acetyl-CoA Carboxylase Alpha), <i>DGAT2</i> <br> 
    (Diacylglycerol O-Acyltransferase 2), <i>FAS</i> (Fatty Acid Synthase), <i>PNPLA2</i> (Patatin-like phospholipase  <br> 
    domain-containing protein 2), <i>PPARG</i> (Peroxisome Proliferator Activated Receptor Gamma).<br>
    <i>p</i>-value: * <i>p</i> < 0.05."
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, face = "italic"),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 10),
    axis.title = element_text(size = 11),
    plot.title = element_text(size = 12, face = "bold"),
    legend.title = element_blank(),
    legend.text = element_text(size = 6),
    legend.position = "bottom",
    plot.caption = ggtext::element_markdown(size = 7, hjust = 0)
  ) +
  scale_fill_manual(values = c("NC + OA" = "#FFD700", "hsa-miR-144-3p + OA" = "#1F968BFF")) +
  scale_y_continuous(limits = c(0, 4)) +
  geom_text(aes(label = ifelse(!is.na(t_test) & t_test < 0.05, "*", "")), 
            position = position_dodge(0.9), vjust = -0.5, size = 5)

```


